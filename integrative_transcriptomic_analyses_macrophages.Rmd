---
title: "Integrative Transcriptomic Analyses Macrophages"
author: "Andrew Y.F. Li Yim"
date: "11/14/2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

Macrophages are multifunctional innate immune cells that play a central role in the spatiotemporal regulation of homeostasis between pro-inflammatory defense response and anti-inflammatory tissue repair. Dysregulation of the tissue-resident and hematogenic macrophages has been implicated in a variety of disorders, such as rheumatoid arthritis (RA), asthma, chronic obstructive pulmonary disorder (COPD), and obesity. As *in vivo* macrophages are difficult to study, in vitro peripheral blood monocyte derived macrophages (MDMs) have been used extensively as model systems for assessing their response to various stimuli. It remains unknown to what extent *in vitro* macrophages represent *in vivo* macrophages. In this project we (Andrew Y.F. Li Yim and Oliver H.J. Chen) sought to perform an integrative analysis on different macrophage activation states. Specifically, we will investigate:
* M0
* M-LPSearly
* M-LPSlate
* M-LPS+IFNg
* M-IFNg
* M-IL4
* M-IL10
* M-dex

This document describes the analyses performed and the choices that have been made as well as the thought processes behind them.

```{r setup, echo = F}
require(Cairo)
require(foreach)
require(ggplot2)
require(reshape2)
require(grid)
require(gridExtra)
require(ggpubr)
require(org.Hs.eg.db)
require(AnnotationDbi)
require(RColorBrewer)
require(pheatmap)
require(NDlib) #https://github.com/ND91/ndlib

dataDir <- file.path("data")
rdataDir <- file.path(dataDir, "rdata")
dir.create(rdataDir)

outputDir <- file.path("output")
dir.create(outputDir)

docDir <- file.path("docs")
dir.create(docDir)

qcDir <- file.path(outputDir, "qc")
dir.create(qcDir)

edaDir <- file.path(outputDir, "eda")
dir.create(edaDir)

maDir <- file.path(outputDir, "meta_analysis")
dir.create(maDir)

clDir <- file.path(outputDir, "elasticnet")
dir.create(clDir)

#Colors
Mcolors <- c(M0 = "#A4A4A4", 
             MLPSearly = "#F5A9A9", 
             MLPSlate = "#B40404", 
             MLPSIFNg = "#FF8000", 
             MIFNg = "#FACC2E", 
             MIL4 = "#74DF00", 
             MIL10 = "#2E9AFE", 
             Mdex = "#BE81F7")

#gg colors (sourced from: https://stackoverflow.com/questions/8197559/emulate-ggplot2-default-color-palette)
gg_color_hue <- function(n){
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

#colorblind palette
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

#Sample import and processing

Prior to starting this study, Oliver had performed an extensive databse search to find studies that had investigated all kinds of macrophages. To this end, an extensive list of datasets was compiled to train, verify, and test the data. Overview:
* 206 datasets on *in vitro* activated M-CSF differentiated macrophages from 19 different studies were used for the meta-analysis as well as the training and testing of the classifier, 
* 34 datasets on *in vitro* activated GM-CSF differentiated macrophages from 3 different studies were used for investigating whether the classifier was capable of classifying GM-CSF differentiated macrophages as well,
* 175 datasets on non-macrophage cells from 4 different studies were used to investigate how the classifier would work when provided with non-macrophages as input, and
* 161 datasets on *in vivo* macrophages from 9 different studies were used to investigate how the classifier would work when provided with *in vivo* macrophages as input.

The first step is to import the samples and split the samples according to their cohort. Per analysis, the cohorts will need to be split up even further.

```{r samples metadata import, results = "hide"}
samples <- read.csv(file.path(dataDir, "samples", "samplesheet_PRJ0000004_MACMETA.csv"), sep = ";", stringsAsFactors = F)
```

For the purpose of importing the data, the data can be broadly subdivided according to experiment (RNAseq vs microarray) after which the microarray data can be subdivided into source of the data, where datasets from Gene Expression Omnibus [(GEO)](https://www.ncbi.nlm.nih.gov/geo/) and ArrayExpress [(AE)](https://www.ebi.ac.uk/arrayexpress/) would need to be imported and processed differently. 

```{r samples splitting, results = "hide"}
samples_rnaseq <- samples[samples$Platform == "RNAseq",]
samples_microarray <- samples[samples$Platform == "Microarray",]
samples_microarray_split <- split(x = samples_microarray, paste0(samples_microarray$StudyID, "_", samples_microarray$PlatformID))
```

##Microarray gene expression data

For the purpose of this study, we will be downloading data and storing it in a data directory called `microarrays`. 

```{r setup microarray import, results = "hide"}
#Microarray directory 
microarrayDir <- file.path(dataDir, "microarrays")
dir.create(microarrayDir)

#Source database
samples_microarray_geo <- samples_microarray[samples_microarray$SourceDB == "GEO",]
samples_microarray_ae <- samples_microarray[samples_microarray$SourceDB == "AE",]

studies_microarray_geo <- unique(samples_microarray_geo$StudyID)
studies_microarray_ae <- unique(samples_microarray_ae$StudyID)
```

###Gene Expression Omnibus 

####Import

We will use the GEOquery package to download all the datasets. The `getGEO()` function will download only the normalized data. This is fine, as the normalized data is imported as an `expressionSet` object, which includes the sample information and other annotation data. However, we would also want the raw data. To that end, we will need to use the `getGEOSuppFiles()` function as well. As downloading is reasonably time-consuming (and likely NCBI does not enjoy getting hit excessively), we will write a wrapper function to perform the download if none of the files are present in the microarray directory (i.e. you downloaded them previously).
During the download you might notice that some of the datasets were obtained from studies that had performed multiple experiments. `GSE5099` contains two experiments: one run on the Affymetrix U133A and one run on the Affymetrix U113B. We can distinguish the datasets from one another using the PlatformID, which is `GPL96` and `GPL97` for U133A and U133B respectively. Similarly, `GSE49604` contains two datasets as well `GPL8432` and `GPL10558`. We are only interested in `GPL96` from `GSE5099` and both `GPL8432` and `GPL10558` from `GSE49604`. To ease downstream processing, we will simply ignore the download thereof.

```{r geo download, results = "hide"}
require(GEOquery)

raw_microarrayDir <- file.path(microarrayDir, "raw_datasets")

geo_importer <- function(GEOID, force_norm_dl = F, raw_dl = F, dataDir){
  #This function is a wrapper function of the GEO importing functions in the GEOquery package. It will try and look for existing GEO files in the indicated directory and if it does not find the files, it will download the data and save the microarrays in a directory you specify.
  #GEOID: The GEO identifier of the microarray of interest.
  #force_norm_dl: Boolean to force the download of the normalized data (even if the file exists already).
  #force_raw_dl: Boolean to download of the raw data.
  
  if(is.null(dataDir)) stop("Cannot find directory to store GEO data")
  
  if(GEOID == "GSE5099"){
    GEOID <- "GSE5099-GPL96"
  } 
  GEOID_path <- file.path(dataDir, paste0(GEOID, "_series_matrix.txt.gz"))
  
  #Download the raw data if the directory does not exist else untar the file
  if(raw_dl == T){
    rawDir <- file.path(dataDir, GEOID)
    raw_geo <- paste0(GEOID, "_RAW.tar")
    
    raw_geo_path <- file.path(rawDir, raw_geo)
    
    if(file.exists(raw_geo_dir)){
      untar(tarfile = raw_geo_path, exdir = rawDir)
    } else{
      warning(paste("Could not find the RAW.tar for", GEOID, ". Downloading now."))
      getGEOSuppFiles(GEO = GEOID, baseDir = dataDir)
      untar(tarfile = raw_geo_path, exdir = rawDir)
    }
  }

  #Download the processed data if the directory does not exist
  if(!file.exists(GEOID_path) | force_norm_dl){
    return(getGEO(GEO = tolower(GEOID), destdir = dataDir)) 
  } else{
    return(getGEO(filename = GEOID_path))
  }
}

#Import prenormalized data if it exists already
if(file.exists(file.path(rdataDir, "prenormalized_microarray_geo.Rds"))){
  microarray_geo_data <- readRDS(file.path(rdataDir, "prenormalized_microarray_geo.Rds"))
} else{
  #Post-download processing of the objects
  microarray_geo_data <- lapply(X = studies_microarray_geo, FUN = geo_importer, dataDir = raw_microarrayDir)
  microarray_geo_data <- do.call(what = c, args = unlist(microarray_geo_data, recursive = F))
  microarray_geo_id <- paste0(studies_microarray_geo, "_", unlist(lapply(microarray_geo_data, function(microarray){annotation(microarray)})))
  names(microarray_geo_data) <- microarray_geo_id
  saveRDS(microarray_geo_data, file.path(rdataDir, "prenormalized_microarray_geo.Rds"))
}
```

To distinguish these datasets from one another, we renamed the list of `expressionSet` objects according to their StudyID and PlatformID.

Having downloaded and imported the data in R, the next step would be to perform a quick check to see whether the data looks OK. We can simply perform a `head` on each dataset.

```{r geo studies check}
lapply(microarray_geo_data, function(i){head(exprs(i))})
```

From the previous import we notice two particular studies peculiarities, namely `GSE47538` and `GSE19765` display a lot of `NA` at first sight.

```{r gse47538 and gse19765}
head(exprs(microarray_geo_data$GSE47538_GPL13497), n = 10)
head(exprs(microarray_geo_data$GSE19765_GPL6102), n = 10)
```

For `GPL13497` we observe that the `rownames` start with a `(+)E1A`, which upon checking with the spec sheet of `GPL13497` know to be a positive control probe. Naturally, they will not have any signal. I am not sure why the top probes for `GSE19765` are `NA`. Nonetheless, probes further down appear to be non-empty.

####Preprocessing
As preprocessed data is not always performed in a similar fashion, we would want to perform our own "universal" preprocessing. It should be understood that preprocessing cannot be truly universal as the microarrays we have downloaded previously are obtained from different platforms, each of which have their own technical peculiarities. As such, preprocessing will need to be done in a platform specific manner. Luckily however, some of the preprocessing steps are universal, or at least have been implemented for different platforms, such as [quantile normalization](https://en.wikipedia.org/wiki/Quantile_normalization), which we will be using later on. Most preprocessing methods consist of two major steps:
1. Background correction, and
2. Normalization.
Note that we will only perform normalization for the meta-analysis. For the elastic net classification analysis we will do no normalization as that might introduce [data leakage](https://machinelearningmastery.com/data-leakage-machine-learning/). For this reason we will need create `expressionSet` of the _normalized_ and _non-normalized data_.
Given this information, we will perform the following preprocessing methods for the following microarray platforms:
* Affymetrix: RMA background correction + quantile normalization
* Illumina: nec background correction + quantile normalization
* Agilent: nec background correction + quantile normalization

```{r setup microarray preprocessing, results = "hide"}
require(oligo)
require(limma)

norm_microarrayDir <- file.path(microarrayDir, "normalized_datasets")
dir.create(norm_microarrayDir)

norm_microarray_list <- list()

nonnorm_microarrayDir <- file.path(microarrayDir, "nonnormalized_datasets")
dir.create(nonnorm_microarrayDir)

nonnorm_microarray_list <- list()
```

#####Affymetrix

Affymetrix microarrays are generally imported using the `rma` function, which performs background correction and quantile normalization by default. The `rma` function was implemented in the `affy` package, but later microarrays from Affymetrix could not be imported through `affy`. As such, the `oligo` package was developed to allow for the import of both the newer and older arrays. We will use `oligo` for importing the affymetrix arrays.

* `GSE5099`
The `GSE5099` dataset consists of two separate microarray datasets, Affymetrix U133A (`GPL96`) and U133B (`GPL97`), we will only use the U133A microarray.

```{r GSE5099_GPL96, results = "hide"}
gse5099_path <- file.path(raw_microarrayDir, "GSE5099")
gse5099_targets <- read.delim(file = file.path(gse5099_path, "filelist.txt"))
colnames(gse5099_targets) <- c("Archive", "FileName", "Time", "Size", "Type")

#Extract only the CEL files from the U133A microarray
gse5099A_targets <- gse5099_targets[grep("chipA.CEL", gse5099_targets$FileName), ]

gse5099A_raw <- oligo::read.celfiles(filenames = file.path(gse5099_path, as.character(gse5099A_targets[, "FileName"])))

#No normalization
gse5099A_nonorm <- oligo::rma(gse5099A_raw, normalize = F)
colnames(gse5099A_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse5099A_nonorm))

nonnorm_microarray_list$GSE5099_GPL96 <- ExpressionSet(assayData = exprs(gse5099A_nonorm),
                                                       phenoData = microarray_geo_data$GSE5099_GPL96@phenoData,
                                                       annotation = "GPL96", 
                                                       featureData = featureData(gse5099A_nonorm))

saveRDS(nonnorm_microarray_list$GSE5099_GPL96, file.path(nonnorm_microarrayDir, "gse5099_GPL96_nonnormalized.Rds"))

#Normalized
gse5099A_norm <- oligo::rma(gse5099A_raw)
colnames(gse5099A_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse5099A_norm))

norm_microarray_list$GSE5099_GPL96 <- ExpressionSet(assayData = exprs(gse5099A_norm),
                                                    phenoData = microarray_geo_data$GSE5099_GPL96@phenoData,
                                                    annotation = "GPL96", 
                                                    featureData = featureData(gse5099A_norm))

saveRDS(norm_microarray_list$GSE5099_GPL96, file.path(norm_microarrayDir, "gse5099_GPL96_normalized.Rds"))
```

* `GSE22528`
Untarring `GSE22528` does not yield a `filelist.txt`, so we will need to resort to importing the `*.CEL.gz` files manually.

```{r GSE22528_GPL96, results = "hide"}
gse22528_path <- file.path(raw_microarrayDir, "GSE22528")
gse22528_targets <- list.files(gse22528_path)[grep(".CEL.gz", list.files(gse22528_path))]

gse22528_raw <- oligo::read.celfiles(filenames = file.path(gse22528_path, as.character(gse22528_targets)))

#No normalization
gse22528_nonorm <- oligo::rma(gse22528_raw, normalize = F)
colnames(gse22528_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse22528_nonorm))

nonnorm_microarray_list$GSE22528_GPL96 <- ExpressionSet(assayData = exprs(gse22528_nonorm),
                                                        phenoData = microarray_geo_data$GSE22528_GPL96@phenoData,
                                                        annotation = "GPL96", 
                                                        featureData = featureData(gse22528_nonorm))

saveRDS(nonnorm_microarray_list$GSE22528_GPL96, file.path(nonnorm_microarrayDir, "gse22528_GPL96_nonnormalized.Rds"))

#Normalized
gse22528_norm <- oligo::rma(gse22528_raw)
colnames(gse22528_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse22528_norm))

norm_microarray_list$GSE22528_GPL96 <- ExpressionSet(assayData = exprs(gse22528_norm),
                                                          phenoData = microarray_geo_data$GSE22528_GPL96@phenoData,
                                                          annotation = "GPL96", 
                                                          featureData = featureData(gse22528_norm))

saveRDS(norm_microarray_list$GSE22528_GPL96, file.path(norm_microarrayDir, "gse22528_GPL96_normalized.Rds"))
```

* `GSE2125`

```{r GSE2125_GPL570, results = "hide"}
gse2125_path <- file.path(raw_microarrayDir, "GSE2125")
gse2125_targets <- list.files(gse2125_path)[grep(".CEL.gz", list.files(gse2125_path))]

gse2125_raw <- oligo::read.celfiles(filenames = file.path(gse2125_path, as.character(gse2125_targets)))

#No normalization
gse2125_nonorm <- oligo::rma(gse2125_raw, normalize = F)
colnames(gse2125_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse2125_nonorm))

nonnorm_microarray_list$GSE2125_GPL570 <- ExpressionSet(assayData = exprs(gse2125_nonorm),
                                                        phenoData = microarray_geo_data$GSE2125_GPL570@phenoData,
                                                        annotation = "GPL570", 
                                                        featureData = featureData(gse2125_nonorm))

saveRDS(nonnorm_microarray_list$gse2125_GPL570, file.path(nonnorm_microarrayDir, "gse2125_GPL570_nonnormalized.Rds"))

#Normalized
gse2125_norm <- oligo::rma(gse2125_raw)
colnames(gse2125_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse2125_norm))

norm_microarray_list$GSE2125_GPL570 <- ExpressionSet(assayData = exprs(gse2125_norm),
                                                     phenoData = microarray_geo_data$GSE2125_GPL570@phenoData,
                                                     annotation = "GPL570", 
                                                     featureData = featureData(gse2125_norm))

saveRDS(norm_microarray_list$GSE2125_GPL570, file.path(norm_microarrayDir, "gse2125_GPL570_normalized.Rds"))
```

* `GSE7368`

```{r GSE7368_GPL570, results = "hide"}
gse7368_path <- file.path(raw_microarrayDir, "GSE7368")
gse7368_targets <- list.files(gse7368_path)[grep(".CEL.gz", list.files(gse7368_path))]

gse7368_raw <- oligo::read.celfiles(filenames = file.path(gse7368_path, as.character(gse7368_targets)))

#No normalization
gse7368_nonorm <- oligo::rma(gse7368_raw, normalize = F)
colnames(gse7368_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse7368_nonorm))

nonnorm_microarray_list$GSE7368_GPL570 <- ExpressionSet(assayData = exprs(gse7368_nonorm),
                                                        phenoData = microarray_geo_data$GSE7368_GPL570@phenoData,
                                                        annotation = "GPL570", 
                                                        featureData = featureData(gse7368_nonorm))

saveRDS(nonnorm_microarray_list$GSE7368_GPL570, file.path(nonnorm_microarrayDir, "gse7368_GPL570_nonnormalized.Rds"))

#Normalized
gse7368_norm <- oligo::rma(gse7368_raw)
colnames(gse7368_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse7368_norm))

norm_microarray_list$GSE7368_GPL570 <- ExpressionSet(assayData = exprs(gse7368_norm),
                                                     phenoData = microarray_geo_data$GSE7368_GPL570@phenoData,
                                                     annotation = "GPL570", 
                                                     featureData = featureData(gse7368_norm))

saveRDS(norm_microarray_list$GSE7368_GPL570, file.path(norm_microarrayDir, "gse7368_GPL570_normalized.Rds"))
```

* `GSE13896`

```{r GSE13896_GPL570, results = "hide"}
gse13896_path <- file.path(raw_microarrayDir, "GSE13896")
gse13896_targets <- list.files(gse13896_path)[grep(".CEL.gz", list.files(gse13896_path))]

gse13896_raw <- oligo::read.celfiles(filenames = file.path(gse13896_path, as.character(gse13896_targets)))

#No normalization
gse13896_nonorm <- oligo::rma(gse13896_raw, normalize = F)
colnames(gse13896_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse13896_nonorm))

nonnorm_microarray_list$GSE13896_GPL570 <- ExpressionSet(assayData = exprs(gse13896_nonorm),
                                                         phenoData = microarray_geo_data$GSE13896_GPL570@phenoData,
                                                         annotation = "GPL570", 
                                                         featureData = featureData(gse13896_nonorm))

saveRDS(nonnorm_microarray_list$GSE13896_GPL570, file.path(nonnorm_microarrayDir, "gse13896_GPL570_nonnormalized.Rds"))

#Normalized
gse13896_norm <- oligo::rma(gse13896_raw)
colnames(gse13896_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse13896_norm))

norm_microarray_list$GSE13896_GPL570 <- ExpressionSet(assayData = exprs(gse13896_norm),
                                                      phenoData = microarray_geo_data$GSE13896_GPL570@phenoData,
                                                      annotation = "GPL570", 
                                                      featureData = featureData(gse13896_norm))

saveRDS(norm_microarray_list$GSE13896_GPL570, file.path(norm_microarrayDir, "gse13896_GPL570_normalized.Rds"))
```

* `GSE93776`

```{r GSE93776_GPL570, results = "hide"}
gse93776_path <- file.path(raw_microarrayDir, "GSE93776")
gse93776_targets <- list.files(gse93776_path)[grep(".CEL.gz", list.files(gse93776_path))]

gse93776_raw <- oligo::read.celfiles(filenames = file.path(gse93776_path, as.character(gse93776_targets)))

#No normalization
gse93776_nonorm <- oligo::rma(gse93776_raw, normalize = F)
colnames(gse93776_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse93776_nonorm))

nonnorm_microarray_list$GSE93776_GPL570 <- ExpressionSet(assayData = exprs(gse93776_nonorm),
                                                         phenoData = microarray_geo_data$GSE93776_GPL570@phenoData,
                                                         annotation = "GPL570", 
                                                         featureData = featureData(gse93776_nonorm))

saveRDS(nonnorm_microarray_list$GSE93776_GPL570, file.path(nonnorm_microarrayDir, "gse93776_GPL570_nonnormalized.Rds"))

#Normalized
gse93776_norm <- oligo::rma(gse93776_raw)
colnames(gse93776_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse93776_norm))

norm_microarray_list$GSE93776_GPL570 <- ExpressionSet(assayData = exprs(gse93776_norm),
                                                      phenoData = microarray_geo_data$GSE93776_GPL570@phenoData,
                                                      annotation = "GPL570", 
                                                      featureData = featureData(gse93776_norm))

saveRDS(norm_microarray_list$GSE93776_GPL570, file.path(norm_microarrayDir, "gse93776_GPL570_normalized.Rds"))
```

* `GSE97779`

```{r GSE97779_GPL570, results = "hide"}
gse97779_path <- file.path(raw_microarrayDir, "GSE97779")
gse97779_targets <- list.files(gse97779_path)[grep(".CEL.gz", list.files(gse97779_path))]

gse97779_raw <- oligo::read.celfiles(filenames = file.path(gse97779_path, as.character(gse97779_targets)))

#No normalization
gse97779_nonorm <- oligo::rma(gse97779_raw, normalize = F)
colnames(gse97779_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse97779_nonorm))

nonnorm_microarray_list$GSE97779_GPL570 <- ExpressionSet(assayData = exprs(gse97779_nonorm),
                                                         phenoData = microarray_geo_data$GSE97779_GPL570@phenoData,
                                                         annotation = "GPL570", 
                                                         featureData = featureData(gse97779_nonorm))

saveRDS(nonnorm_microarray_list$GSE97779_GPL570, file.path(nonnorm_microarrayDir, "gse97779_GPL570_nonnormalized.Rds"))

#Normalized
gse97779_norm <- oligo::rma(gse97779_raw)
colnames(gse97779_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse97779_norm))

norm_microarray_list$GSE97779_GPL570 <- ExpressionSet(assayData = exprs(gse97779_norm),
                                                      phenoData = microarray_geo_data$GSE97779_GPL570@phenoData,
                                                      annotation = "GPL570", 
                                                      featureData = featureData(gse97779_norm))

saveRDS(norm_microarray_list$GSE97779_GPL570, file.path(norm_microarrayDir, "gse97779_GPL570_normalized.Rds"))
```

* `GSE10500`

```{r GSE10500_GPL8300, results = "hide"}
gse10500_path <- file.path(raw_microarrayDir, "GSE10500")
gse10500_targets <- list.files(gse10500_path)[grep(".CEL.gz", list.files(gse10500_path))]

gse10500_raw <- oligo::read.celfiles(filenames = file.path(gse10500_path, as.character(gse10500_targets)))

#No normalization
gse10500_nonorm <- oligo::rma(gse10500_raw, normalize = F)
colnames(gse10500_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse10500_nonorm))

nonnorm_microarray_list$GSE10500_GPL8300 <- ExpressionSet(assayData = exprs(gse10500_nonorm),
                                                          phenoData = microarray_geo_data$GSE10500_GPL8300@phenoData,
                                                          annotation = "GPL8300", 
                                                          featureData = featureData(gse10500_nonorm))

saveRDS(nonnorm_microarray_list$GSE10500_GPL8300, file.path(nonnorm_microarrayDir, "gse10500_GPL8300_nonnormalized.Rds"))

#Normalized
gse10500_norm <- oligo::rma(gse10500_raw)
colnames(gse10500_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse10500_norm))

norm_microarray_list$GSE10500_GPL8300 <- ExpressionSet(assayData = exprs(gse10500_norm),
                                                       phenoData = microarray_geo_data$GSE10500_GPL8300@phenoData,
                                                       annotation = "GPL8300", 
                                                       featureData = featureData(gse10500_norm))

saveRDS(norm_microarray_list$GSE10500_GPL8300, file.path(norm_microarrayDir, "gse10500_GPL8300_normalized.Rds"))
```

* `GSE30177`
The series `GSE30177` uses an Affymetrix microarray, which measures exons instead of genes. We will annotate the probes using the transcripts because the annotations are extracted from the GPL associated with the pre-normalized data. This means we have to perform an extra merging step later on.

```{r GSE30177_GPL10739, results = "hide"}
gse30177_path <- file.path(raw_microarrayDir, "GSE30177")
gse30177_targets <- read.delim(file = file.path(gse30177_path, "filelist.txt"))
colnames(gse30177_targets) <- c("Archive", "FileName", "Time", "Size", "Type")
gse30177_targets <- gse30177_targets[which(gse30177_targets$Type == "CEL"), ]

gse30177_raw <- oligo::read.celfiles(filenames = file.path(gse30177_path, as.character(gse30177_targets[, "FileName"])))

#Non-normalized
gse30177_nonnorm <- oligo::rma(object = gse30177_raw, normalize = F, target = "probeset")
colnames(gse30177_nonnorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse30177_nonnorm))
featureData(gse30177_nonnorm) <- oligo::getNetAffx(gse30177_nonnorm, "probeset")
nonnorm_microarray_list$GSE30177_GPL10739 <- ExpressionSet(assayData = exprs(gse30177_nonnorm),
                                                           phenoData = microarray_geo_data$GSE30177_GPL10739@phenoData,
                                                           annotation = "GPL10739", 
                                                           featureData = featureData(gse30177_nonnorm))
saveRDS(nonnorm_microarray_list$GSE30177_GPL10739, file.path(nonnorm_microarrayDir, "gse30177_GPL10739_nonnormalized.Rds"))

#Normalized
gse30177_norm <- oligo::rma(object = gse30177_raw, target = "probeset")
colnames(gse30177_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse30177_norm))
featureData(gse30177_norm) <- oligo::getNetAffx(gse30177_norm, "probeset")
norm_microarray_list$GSE30177_GPL10739 <- ExpressionSet(assayData = exprs(gse30177_norm),
                                                        phenoData = microarray_geo_data$GSE30177_GPL10739@phenoData,
                                                        annotation = "GPL10739", 
                                                        featureData = featureData(gse30177_norm))
saveRDS(norm_microarray_list$GSE30177_GPL10739, file.path(norm_microarrayDir, "gse30177_GPL10739_normalized.Rds"))
```

* `GSE61880`

```{r GSE61880_GPL13158, results = "hide"}
gse61880_path <- file.path(raw_microarrayDir, "GSE61880")
gse61880_targets <- read.delim(file = file.path(gse61880_path, "filelist.txt"))
colnames(gse61880_targets) <- c("Archive", "FileName", "Time", "Size", "Type")
gse61880_targets <- gse61880_targets[grep("\\.CEL", gse61880_targets$FileName), ]

gse61880_raw <- oligo::read.celfiles(filenames = file.path(gse61880_path, as.character(gse61880_targets[, "FileName"])))

#No normalization
gse61880_nonorm <- oligo::rma(gse61880_raw, normalize = F)
colnames(gse61880_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse61880_nonorm))

nonnorm_microarray_list$GSE61880_GPL13158 <- ExpressionSet(assayData = exprs(gse61880_nonorm),
                                                           phenoData = microarray_geo_data$GSE61880_GPL13158@phenoData,
                                                           annotation = "GPL13158",
                                                           featureData = featureData(gse61880_nonorm))

saveRDS(nonnorm_microarray_list$GSE61880_GPL13158, file.path(nonnorm_microarrayDir, "gse61880_GPL13158_nonnormalized.Rds"))

#Normalized
gse61880_norm <- oligo::rma(gse61880_raw)
colnames(gse61880_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse61880_norm))

norm_microarray_list$GSE61880_GPL13158 <- ExpressionSet(assayData = exprs(gse61880_norm),
                                                        phenoData = microarray_geo_data$GSE61880_GPL13158@phenoData,
                                                        annotation = "GPL13158",
                                                        featureData = featureData(gse61880_norm))

saveRDS(norm_microarray_list$GSE61880_GPL13158, file.path(norm_microarrayDir, "gse61880_GPL13158_normalized.Rds"))
```

* `GSE75938`
The series `GSE75938` is was performed using an Affymetrix primeview microarray. Unlike the more common U-series of Affymetrix, finding the microarray layout appears to be problematic. There appears to be a `primeviewcdf` package available on Bioconductor, but unfortunately this loads an environment, which I cannot utilize in the import. I thought I had found the CDF file from this [Bioconductor thread](https://support.bioconductor.org/p/55602/), but unfortunately no CDF was provided in the link to the Affymetrix website. This study is only used in the non-training set, specifically the non-macrophage cells. So I therefore imported the prenormalized data as provided by the authors.

```{r GSE75938_GPL15207, results = "hide"}
#Normalized
norm_microarray_list$GSE75938_GPL15207 <- ExpressionSet(assayData = microarray_geo_data$GSE75938_GPL15207@assayData,
                                                        phenoData = microarray_geo_data$GSE75938_GPL15207@phenoData,
                                                        annotation = "GPL15207",
                                                        featureData = microarray_geo_data$GSE75938_GPL15207@featureData)

#Log2 transform
exprs(norm_microarray_list$GSE75938_GPL15207) <- log2(exprs(norm_microarray_list$GSE75938_GPL15207))

saveRDS(norm_microarray_list$GSE75938_GPL15207, file.path(norm_microarrayDir, "gse75938_GPL15207_normalized.Rds"))
```

#####Illumina

Illumina data is generally stored in a file named `GSE[0-9]+_Non-normalized.txt`. Such files can be imported using `limma::read.ilmn()` after which `limma::neqc()` (or `limma::nec()` for non-normalized values) can be used for background correction and normalization. A colleague of mine (Dr. Perry Moerland) highlighted one aspect to look out for: raw Illumina data is not always "raw". The "raw"" datasets were sometimes exported using Illumina BeadStudio, which performs its own background correction. One can confirm a background correction by investigating whether the minimum expression (as stored in `raw$E`) is a positive value. If the returned value is smaller than 0, then the data has been background corrected, which can be fixed by adding an offset to each individual array thereby making the value positive again. For a discussion on this topic check out this  (thread)[https://stat.ethz.ch/pipermail/bioconductor/2011-May/039282.html]. 
Note that the raw values from `limma:nec()` do not yield log-transformed values by default. 

* `GSE19765`
This series had several datasets with `NA` values. Such `NA` values must be removed as R coerces the detection *p*-values into `character` instead of `numeric`. As these values are `null` for all arrays, the best strategy is to remove them.

```{r GSE19765_GPL6102, results = "hide"}
gse19765_raw <- limma::read.ilmn(file = file.path(raw_microarrayDir, "GSE19765", "GSE19765_Human_RAW.txt"), 
                                 probeid = "ID_REF", 
                                 expr = "SAMPLE")
colnames(gse19765_raw) <- colnames(microarray_geo_data$GSE19765_GPL6102)

gse19765_null <- which(gse19765_raw$other$Detection == "null", arr.ind = T)
table(gse19765_null[,2])
gse19765_raw <- gse19765_raw[-unique(gse19765_null[,1]), ]
gse19765_raw$other$Detection <- matrix(data = as.numeric(gse19765_raw$other$Detection), 
                                       nrow = nrow(gse19765_raw$other$Detection),
                                       ncol = ncol(gse19765_raw$other$Detection),
                                       dimnames = dimnames(gse19765_raw$other$Detection))

min(gse19765_raw$E)

#No normalization
gse19765_nonorm <- limma::nec(gse19765_raw)
gse19765_nonorm$E <- log2(gse19765_nonorm$E)

nonnorm_microarray_list$GSE19765_GPL6102 <- ExpressionSet(assayData = gse19765_nonorm$E,
                                                          phenoData = microarray_geo_data$GSE19765_GPL6102@phenoData,
                                                          annotation = "GPL6102")

saveRDS(nonnorm_microarray_list$GSE19765_GPL6102, file.path(nonnorm_microarrayDir, "gse19765_GPL6102_nonnormalized.Rds"))

#Normalized
gse19765_norm <- limma::neqc(gse19765_raw)

norm_microarray_list$GSE19765_GPL6102 <- ExpressionSet(assayData = gse19765_norm$E,
                                                       phenoData = microarray_geo_data$GSE19765_GPL6102@phenoData,
                                                       annotation = "GPL6102")

saveRDS(norm_microarray_list$GSE19765_GPL6102, file.path(norm_microarrayDir, "gse19765_GPL6102_normalized.Rds"))
```

* `GSE18686`

```{r GSE18686_GPL6947, results = "hide"}
gse18686_raw <- limma::read.ilmn(file = file.path(raw_microarrayDir, "GSE18686", "GSE18686_nonnormalized.txt"), 
                                 probeid = "ID_REF", 
                                 expr = "Batch")
colnames(gse18686_raw) <- colnames(microarray_geo_data$GSE18686_GPL6947)

min(gse18686_raw$E)

#No normalization
gse18686_nonorm <- limma::nec(gse18686_raw)
gse18686_nonorm$E <- log2(gse18686_nonorm$E)

nonnorm_microarray_list$GSE18686_GPL6947 <- ExpressionSet(assayData = gse18686_nonorm$E,
                                                          phenoData = microarray_geo_data$GSE18686_GPL6947@phenoData,
                                                          annotation = "GPL6947")

saveRDS(nonnorm_microarray_list$GSE18686_GPL6947, file.path(nonnorm_microarrayDir, "gse18686_GPL6947_nonnormalized.Rds"))

#Normalized
gse18686_norm <- limma::neqc(gse18686_raw)

norm_microarray_list$GSE18686_GPL6947 <- ExpressionSet(assayData = gse18686_norm$E,
                                                       phenoData = microarray_geo_data$GSE18686_GPL6947@phenoData,
                                                       annotation = "GPL6947")

saveRDS(norm_microarray_list$GSE18686_GPL6947, file.path(norm_microarrayDir, "gse18686_GPL6947_normalized.Rds"))
```

* `GSE46903`
The raw data from `GSE46903` has been annotated with a non-standard Illumina identifier. Given that this study will only be used in the *in vivo* and verification of GM-CSF differentiated macrophage classification, we will simply utilize the prenormalized data as provided by the authors.  

```{r GSE46903_GPL6947, results = "hide"}
norm_microarray_list$GSE46903_GPL6947 <- ExpressionSet(assayData = microarray_geo_data$GSE46903_GPL6947@assayData,
                                                       phenoData = microarray_geo_data$GSE46903_GPL6947@phenoData,
                                                       annotation = "GPL6947",
                                                       featureData = microarray_geo_data$GSE46903_GPL6947@featureData)

saveRDS(norm_microarray_list$GSE46903_GPL6947, file.path(norm_microarrayDir, "gse46903_GPL6947_normalized.Rds"))
```

* `GSE49604`
The series `GSE490604` does not provide any detection *p*-values. Importing it with `limma:nec` is therefore not be possible. Given that this study will only be used during the *in vivo* classification later on, we will utilize the pre-normalized data as provided by the authors.  

```{r GSE49604_GPL8432, results = "hide"}
norm_microarray_list$GSE49604_GPL8432 <- ExpressionSet(assayData = microarray_geo_data$GSE49604_GPL8432@assayData,
                                                       phenoData = microarray_geo_data$GSE49604_GPL8432@phenoData,
                                                       annotation = "GPL8432",
                                                       featureData = microarray_geo_data$GSE49604_GPL8432@featureData)

saveRDS(norm_microarray_list$GSE49604_GPL8432, file.path(norm_microarrayDir, "gse49604_GPL8432_normalized.Rds"))
```


```{r GSE49604_GPL10558, results = "hide"}
norm_microarray_list$GSE49604_GPL10558 <- ExpressionSet(assayData = microarray_geo_data$GSE49604_GPL10558@assayData,
                                                        phenoData = microarray_geo_data$GSE49604_GPL10558@phenoData,
                                                        annotation = "GPL10558",
                                                        featureData = microarray_geo_data$GSE49604_GPL10558@featureData)

saveRDS(norm_microarray_list$GSE49604_GPL10558, file.path(norm_microarrayDir, "gse49604_GPL10558_normalized.Rds"))
```

* `GSE54350`

```{r GSE54350_GPL10558, results = "hide"}
gse54350_path <- file.path(raw_microarrayDir, "GSE54350")

gse54350_raw <- limma::read.ilmn(file = file.path(raw_microarrayDir, "GSE54350", "GSE54350_non-normalized.txt"), 
                                 probeid = "ID_REF", 
                                 expr = "AVG_Signal")
colnames(gse54350_raw) <- colnames(microarray_geo_data$GSE54350_GPL10558)

min(gse54350_raw$E)

#No normalization
gse54350_nonorm <- limma::nec(gse54350_raw)
gse54350_nonorm$E <- log2(gse54350_nonorm$E)

nonnorm_microarray_list$GSE54350_GPL10558 <- ExpressionSet(assayData = gse54350_nonorm$E,
                                                           phenoData = microarray_geo_data$GSE54350_GPL10558@phenoData,
                                                           annotation = "GPL10558")

saveRDS(nonnorm_microarray_list$GSE54350_GPL10558, file.path(nonnorm_microarrayDir, "gse54350_GPL10558_nonnormalized.Rds"))

#Normalized
gse54350_norm <- limma::neqc(gse54350_raw)

norm_microarray_list$GSE54350_GPL10558 <- ExpressionSet(assayData = gse54350_norm$E,
                                                        phenoData = microarray_geo_data$GSE54350_GPL10558@phenoData,
                                                        annotation = "GPL10558")

saveRDS(norm_microarray_list$GSE54350_GPL10558, file.path(norm_microarrayDir, "gse54350_GPL10558_normalized.Rds"))
```

#####Agilent 

The import and preprocessing of Agilent data is identical to that of Illumina. The filelist of the raw data can be used, but the headers need to be renamed (Name > FileName).

* `GSE47538`
GSE47538 has 10 spots that bind to one transcript as a technical control. The solution we implemented for this is to take the mean using the `limma::avereps()` function. Note that we took the mean after log-transformation.

```{r GSE47538_GPL13497, results = "hide"}
gse47538_targets <- limma::readTargets(file = "filelist_proper.txt", path = file.path(raw_microarrayDir, "GSE47538"), sep = "\t")
gse47538_raw <- limma::read.maimages(files = gse47538_targets, path = file.path(raw_microarrayDir, "GSE47538") , source = "agilent", green.only = TRUE)

#No normalization
gse47538_nonorm <- limma::nec(x = gse47538_raw, status = gse47538_raw$genes$ControlType, negctrl = -1, regular = 0)
gse47538_nonorm$E <- log2(gse47538_nonorm$E)

table(table(gse47538_nonorm$genes$ProbeName))
gse47538_nonorm$E <- limma::avereps(gse47538_nonorm$E, ID = gse47538_nonorm$genes$ProbeName)
colnames(gse47538_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse47538_nonorm))

nonnorm_microarray_list$GSE47538_GPL13497 <- ExpressionSet(assayData = gse47538_nonorm$E,
                                                           phenoData = microarray_geo_data$GSE47538_GPL13497@phenoData,
                                                           annotation = "GPL13497")

saveRDS(nonnorm_microarray_list$GSE47538_GPL13497, file.path(nonnorm_microarrayDir, "gse47538_GPL13497_nonnormalized.Rds"))

#Normalized
gse47538_norm <- limma::neqc(x = gse47538_raw, status = gse47538_raw$genes$ControlType, negctrl = -1, regular = 0)

table(table(gse47538_norm$genes$ProbeName))
gse47538_norm <- limma::avereps(gse47538_norm, ID = gse47538_norm$genes$ProbeName)
colnames(gse47538_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse47538_norm))

norm_microarray_list$GSE47538_GPL13497 <- ExpressionSet(assayData = gse47538_norm$E,
                                                        phenoData = microarray_geo_data$GSE47538_GPL13497@phenoData,
                                                        annotation = "GPL13497")

saveRDS(norm_microarray_list$GSE47538_GPL13497, file.path(norm_microarrayDir, "gse47538_GPL13497_normalized.Rds"))
```

* `GSE57614`
Similar to `GSE47538`, `GSE57614` contains several spots that will need to be aggregated.

```{r GSE57614_GPL6480, results = "hide"}
gse57614_targets <- limma::readTargets(file = "filelist_proper.txt", path = file.path(raw_microarrayDir, "GSE57614"), sep = "\t")
gse57614_raw <- limma::read.maimages(files = gse57614_targets, path = file.path(raw_microarrayDir, "GSE57614"), source = "agilent", green.only = TRUE)

#No normalization
gse57614_nonorm <- limma::nec(x = gse57614_raw, status = gse57614_raw$genes$ControlType, negctrl = -1, regular = 0)
gse57614_nonorm$E <- log2(gse57614_nonorm$E)

table(table(gse57614_nonorm$genes$ProbeName))
gse57614_nonorm$E <- limma::avereps(gse57614_nonorm$E, ID = gse57614_nonorm$genes$ProbeName)
colnames(gse57614_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse57614_nonorm))

nonnorm_microarray_list$GSE57614_GPL6480 <- ExpressionSet(assayData = gse57614_nonorm$E,
                                                          phenoData = microarray_geo_data$GSE57614_GPL6480@phenoData,
                                                          annotation = "GPL6480")

saveRDS(nonnorm_microarray_list$GSE57614_GPL6480, file.path(nonnorm_microarrayDir, "gse57614_GPL6480_nonnormalized.Rds"))

#Normalized
gse57614_norm <- limma::neqc(x = gse57614_raw, status = gse57614_raw$genes$ControlType, negctrl = -1, regular = 0)

table(table(gse57614_norm$genes$ProbeName))
gse57614_norm <- limma::avereps(gse57614_norm, ID = gse57614_norm$genes$ProbeName)
colnames(gse57614_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse57614_norm))

norm_microarray_list$GSE57614_GPL6480 <- ExpressionSet(assayData = gse57614_norm$E,
                                                       phenoData = microarray_geo_data$GSE57614_GPL6480@phenoData,
                                                       annotation = "GPL6480")

saveRDS(norm_microarray_list$GSE57614_GPL6480, file.path(norm_microarrayDir, "gse57614_GPL6480_normalized.Rds"))
```

* `GSE85346`

```{r GSE85346_GPL13497, results = "hide"}
gse85346_targets <- limma::readTargets(file = "filelist_proper.txt", path = file.path(raw_microarrayDir, "GSE85346"), sep = "\t")
gse85346_raw <- limma::read.maimages(files = gse85346_targets, path = file.path(raw_microarrayDir, "GSE85346") , source = "agilent", green.only = TRUE)

#No normalization
gse85346_nonorm <- limma::nec(x = gse85346_raw, status = gse85346_raw$genes$ControlType, negctrl = -1, regular = 0)
gse85346_nonorm$E <- log2(gse85346_nonorm$E)

table(table(gse85346_nonorm$genes$ProbeName))
gse85346_nonorm$E <- limma::avereps(gse85346_nonorm$E, ID = gse85346_nonorm$genes$ProbeName)
colnames(gse85346_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse85346_nonorm))

nonnorm_microarray_list$GSE85346_GPL13497 <- ExpressionSet(assayData = gse85346_nonorm$E,
                                                           phenoData = microarray_geo_data$GSE85346_GPL13497@phenoData,
                                                           annotation = "GPL13497")

saveRDS(nonnorm_microarray_list$GSE85346_GPL13497, file.path(nonnorm_microarrayDir, "gse85346_GPL13497_nonnormalized.Rds"))

#Normalized
gse85346_norm <- limma::neqc(x = gse85346_raw, status = gse85346_raw$genes$ControlType, negctrl = -1, regular = 0)

table(table(gse85346_norm$genes$ProbeName))
gse85346_norm <- limma::avereps(gse85346_norm, ID = gse85346_norm$genes$ProbeName)
colnames(gse85346_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse85346_norm))

norm_microarray_list$GSE85346_GPL13497 <- ExpressionSet(assayData = gse85346_norm$E,
                                                        phenoData = microarray_geo_data$GSE85346_GPL13497@phenoData,
                                                        annotation = "GPL13497")

saveRDS(norm_microarray_list$GSE85346_GPL13497, file.path(norm_microarrayDir, "gse85346_GPL13497_normalized.Rds"))
```

* `GSE99056`

```{r GSE99056_GPL13497, results = "hide"}
gse99056_targets <- limma::readTargets(file = "filelist_proper.txt", path = file.path(raw_microarrayDir, "GSE99056"), sep = "\t")
gse99056_raw <- limma::read.maimages(files = gse99056_targets, path = file.path(raw_microarrayDir, "GSE99056"), source = "agilent", green.only = TRUE)

#No normalization
gse99056_nonorm <- limma::nec(x = gse99056_raw, status = gse99056_raw$genes$ControlType, negctrl = -1, regular = 0)
gse99056_nonorm$E <- log2(gse99056_nonorm$E)

table(table(gse99056_nonorm$genes$ProbeName))
gse99056_nonorm$E <- limma::avereps(gse99056_nonorm$E, ID = gse99056_nonorm$genes$ProbeName)
colnames(gse99056_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse99056_nonorm))

nonnorm_microarray_list$GSE99056_GPL13497 <- ExpressionSet(assayData = gse99056_nonorm$E,
                                                           phenoData = microarray_geo_data$GSE99056_GPL13497@phenoData,
                                                           annotation = "GPL13497")

saveRDS(nonnorm_microarray_list$GSE99056_GPL13497, file.path(nonnorm_microarrayDir, "gse99056_GPL13497_nonnormalized.Rds"))

#Normalized
gse99056_norm <- limma::neqc(x = gse99056_raw, status = gse99056_raw$genes$ControlType, negctrl = -1, regular = 0)

table(table(gse99056_norm$genes$ProbeName))
gse99056_norm <- limma::avereps(gse99056_norm, ID = gse99056_norm$genes$ProbeName)
colnames(gse99056_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse99056_norm))

norm_microarray_list$GSE99056_GPL13497 <- ExpressionSet(assayData = gse99056_norm$E,
                                                        phenoData = microarray_geo_data$GSE99056_GPL13497@phenoData,
                                                        annotation = "GPL13497")

saveRDS(norm_microarray_list$GSE99056_GPL13497, file.path(norm_microarrayDir, "gse99056_GPL13497_normalized.Rds"))
```

* `GSE79077`

```{r GSE79077_GPL17077, results = "hide"}
gse79077_targets <- limma::readTargets(file = "filelist_proper.txt", path = file.path(raw_microarrayDir, "GSE79077"), sep = "\t")
gse79077_raw <- limma::read.maimages(files = gse79077_targets, path = file.path(raw_microarrayDir, "GSE79077") , source = "agilent", green.only = TRUE)

#No normalization
gse79077_nonorm <- limma::nec(x = gse79077_raw, status = gse79077_raw$genes$ControlType, negctrl = -1, regular = 0)
gse79077_nonorm$E <- log2(gse79077_nonorm$E)

table(table(gse79077_nonorm$genes$ProbeName))
gse79077_nonorm$E <- limma::avereps(gse79077_nonorm$E, ID = gse79077_nonorm$genes$ProbeName)
colnames(gse79077_nonorm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse79077_nonorm))

nonnorm_microarray_list$GSE79077_GPL17077 <- ExpressionSet(assayData = gse79077_nonorm$E,
                                               phenoData = microarray_geo_data$GSE79077_GPL17077@phenoData,
                                               annotation = "GPL17077")

saveRDS(nonnorm_microarray_list$GSE79077_GPL17077, file.path(nonnorm_microarrayDir, "gse79077_GPL17077_nonnormalized.Rds"))

#Normalized
gse79077_norm <- limma::neqc(x = gse79077_raw, status = gse79077_raw$genes$ControlType, negctrl = -1, regular = 0)

table(table(gse79077_norm$genes$ProbeName))
gse79077_norm <- limma::avereps(gse79077_norm, ID = gse79077_norm$genes$ProbeName)
colnames(gse79077_norm) <- gsub("(GSM[0-9]+)(\\.|_).+", "\\1", colnames(gse79077_norm))

norm_microarray_list$GSE79077_GPL17077 <- ExpressionSet(assayData = gse79077_norm$E,
                                        phenoData = microarray_geo_data$GSE79077_GPL17077@phenoData,
                                        annotation = "GPL17077")

saveRDS(norm_microarray_list$GSE79077_GPL17077, file.path(norm_microarrayDir, "gse79077_GPL17077_normalized.Rds"))
```

###ArrayExpress

Similar to `GEOquery`, the `ArrayExpress` package can imports the data from AE. Unfortunately, the datasets we selected do not appear to be imported well using `getAE(accession = [AE-accession])`. AE data entries contain several files. Two of those files are the `.adf` and the `.sdrf` files, which represent the probe annotations and the sample information respectively. We found that AE did not maintain a strict format for the .sdrf files resulting in some issues with missing commas or tabs.

####Import

```{r ae importer}
require(ArrayExpress)
require(convert)

ae_importer <- function(microarray, download = F){
  ae_accession <- gsub("^([A-Z]{4})([0-9]{3,4})$", "E-\\1-\\2", microarray)
  local_name <- gsub("-", "", ae_accession)
  microarray_path <- file.path(raw_microarrayDir, local_name)
  dir.create(microarray_path)
  
  #Download all data if the folder does not exist or the download is forced
  if(!file.exists(microarray_path) | download){
    return(getAE(accession = ae_accession, type = "full", path = microarray_path)) 
  } else{
    return(getAE(accession = ae_accession, path = microarray_path, local = T, sourcedir = microarray_path))
  }
}

#Import prenormalized data if it exists already
if(file.exists(file.path(rdataDir, "prenormalized_microarray_ae.Rds"))){
  microarray_ae_data <- readRDS(file.path(rdataDir, "prenormalized_microarray_ae.Rds"))
} else{
  #Post-download processing of the objects
  microarray_ae_data <- lapply(X = studies_microarray_ae, FUN = ae_importer, download = T)
  names(microarray_ae_data) <- studies_microarray_ae
  saveRDS(microarray_ae_data, file.path(rdataDir, "prenormalized_microarray_ae.Rds"))
}
```

The function appears to throw a lot of errors that `.adf` files cannot be found. If `getAE` fails to download the `.adf` file, try running `ae_importer(download = T)`. For some reason `getAE` does not see locally stored `.adf` files.

####Preprocessing

#####Affymetrix

* `E-MEXP-3890`

```{r E-MEXP-3890_AAFFY44, results = "hide"}
mexp3890_path <- file.path(raw_microarrayDir, "EMEXP3890")
mexp3890_pdata <- samples_microarray_ae[which(samples_microarray_ae$StudyID == "MEXP3890"),]
mexp3890_sdrf <- read.csv(file.path(mexp3890_path, "E-MEXP-3890.sdrf.txt"), sep = "\t", stringsAsFactors = F)
rownames(mexp3890_sdrf) <- mexp3890_sdrf$Assay.Name <- gsub(" *- *", "_", mexp3890_sdrf$Assay.Name)

mexp3890_raw <- oligo::read.celfiles(filenames = file.path(mexp3890_path, as.character(mexp3890_sdrf[, "Array.Data.File"])))
sampleNames(mexp3890_raw) <- as.character(mexp3890_sdrf$Assay.Name)

#No normalization
mexp3890_nonorm <- oligo::rma(mexp3890_raw, normalize = F)

nonnorm_microarray_list$MEXP3890_AAFFY44 <- ExpressionSet(assayData = exprs(mexp3890_nonorm),
                                                          phenoData = as(mexp3890_sdrf, "AnnotatedDataFrame"),
                                                          annotation = "AAFFY44")

saveRDS(nonnorm_microarray_list$MEXP3890_AAFFY44, file.path(nonnorm_microarrayDir, "mexp3890_AAFFY44_nonnormalized.Rds"))

#Normalized
mexp3890_norm <- oligo::rma(mexp3890_raw, normalize = T)

norm_microarray_list$MEXP3890_AAFFY44 <- ExpressionSet(assayData = exprs(mexp3890_norm),
                                                       phenoData = as(mexp3890_sdrf, "AnnotatedDataFrame"),
                                                       annotation = "AAFFY44")

saveRDS(norm_microarray_list$MEXP3890_AAFFY44, file.path(norm_microarrayDir, "mexp3890_AAFFY44_normalized.Rds"))
```

* `E-MTAB-5913`

```{r E-MTAB-5913_AAFFY44, results = "hide"}
mtab5913_path <- file.path(raw_microarrayDir, "EMTAB5913")
mtab5913_pdata <- samples_microarray_ae[which(samples_microarray_ae$StudyID == "MTAB5913"),]
mtab5913_sdrf <- read.csv(file.path(mtab5913_path, "E-MTAB-5913.sdrf.txt"), sep = "\t", stringsAsFactors = F)
rownames(mtab5913_sdrf) <- mtab5913_sdrf$Assay.Name

mtab5913_raw <- oligo::read.celfiles(filenames = file.path(mtab5913_path, as.character(mtab5913_sdrf[, "Array.Data.File"])))
sampleNames(mtab5913_raw) <- as.character(mtab5913_sdrf$Assay.Name)

#No normalization
mtab5913_nonorm <- oligo::rma(mtab5913_raw, normalize = F)

nonnorm_microarray_list$MTAB5913_AAFFY44 <- ExpressionSet(assayData = exprs(mtab5913_nonorm),
                                                          phenoData = as(mtab5913_sdrf, "AnnotatedDataFrame"),
                                                          annotation = "AAFFY44")

saveRDS(nonnorm_microarray_list$MTAB5913_AAFFY44, file.path(nonnorm_microarrayDir, "mtab5913_AAFFY44_nonnormalized.Rds"))

#Normalized
mtab5913_norm <- oligo::rma(mtab5913_raw, normalize = T)

norm_microarray_list$MTAB5913_AAFFY44 <- ExpressionSet(assayData = exprs(mtab5913_norm),
                                                            phenoData = as(mtab5913_sdrf, "AnnotatedDataFrame"),
                                                            annotation = "AAFFY44")

saveRDS(norm_microarray_list$MTAB5913_AAFFY44, file.path(norm_microarrayDir, "mtab5913_AAFFY44_normalized.Rds"))
```

#####Illumina

* `E-MTAB-3309`

This dataset was generated using the Illumina HT-12 v4 platform. Again, the `ae2bioc()` function will not work as the `readAEdata()` function fails on importing the individual data files. A solution we implemented was to concatenate all the samples into one file and use `limma::read.maimages()` to import the data.
I will thus extract column 1 for the probe names and columns 3 and 4 for the AVG signal and the detection *p*-value, respectively. Using the following range we can obtain exactly the correct indices for the columns of interest: `sort(c(1, 3+4*(0:(ncol(mtab3309_samples_df)/4-1)), 4+4*(0:(ncol(mtab3309_samples_df)/4-1))))`. Notably, sample `9402444007_e` does not contain any `AVG_Signal`, perhaps this is why `readAEdata` failed?

```{r E-MTAB-3309_AMEXP2210, results = "hide"}
mtab3309_path <- file.path(raw_microarrayDir, "EMTAB3309")

mtab3309_sdrf <- read.csv(file.path(mtab3309_path, "E-MTAB-3309.sdrf.txt"), sep = "\t", stringsAsFactors = F)
mtab3309_data <- file.path(mtab3309_path, list.files(mtab3309_path)[grep("Sample_", list.files(mtab3309_path))])
mtab3309_samples <- lapply(mtab3309_data, function(sample){read.csv(sample, sep = "\t", stringsAsFactors = F)})
mtab3309_samples_df <- do.call(cbind, mtab3309_samples)

mtab3309_samples_filtered <- mtab3309_samples_df[, sort(c(1, 3+4*(0:(ncol(mtab3309_samples_df)/4-1)), 4+4*(0:(ncol(mtab3309_samples_df)/4-1))))]
mtab3309_samples_filtered <- mtab3309_samples_filtered[, -which(colnames(mtab3309_samples_filtered) == "X" | colnames(mtab3309_samples_filtered) == "X9402444007_e.Detection.Pval")]
mtab3309_sdrf_filtered <- mtab3309_sdrf[-which(mtab3309_sdrf$Extract.Name == "Sample 5"), ]

colnames(mtab3309_samples_filtered) <- gsub("X[0-9]+.+\\.(Detection)\\.(Pval)", "\\1 \\2",  colnames(mtab3309_samples_filtered))

#Backup
if(!file.exists(file.path(mtab3309_path, "E-MTAB-3309_non_normalized.txt.bak"))){
  file.copy(from = file.path(mtab3309_path, "E-MTAB-3309_non_normalized.txt"), to = file.path(mtab3309_path, "E-MTAB-3309_non_normalized.txt.bak"))
}
write.table(mtab3309_samples_filtered, file = file.path(mtab3309_path, "E-MTAB-3309_non_normalized.txt"), sep = "\t", row.names = F)

mtab3309_raw <- limma::read.ilmn(file = file.path(mtab3309_path, "E-MTAB-3309_non_normalized_filtered.txt"), probeid = "PROBE_ID", expr = "AVG_Signal")

#No normalization
mtab3309_nonorm <- limma::nec(mtab3309_raw)
mtab3309_nonorm$E <- log2(mtab3309_nonorm$E)

rownames(mtab3309_sdrf_filtered) <- colnames(mtab3309_nonorm)

nonnorm_microarray_list$MTAB3309_AMEXP2210 <- ExpressionSet(assayData = mtab3309_nonorm$E,
                                                            phenoData = as(mtab3309_sdrf_filtered, "AnnotatedDataFrame"),
                                                            annotation = "AMEXP2210")

saveRDS(nonnorm_microarray_list$MTAB3309_AMEXP2210, file.path(nonnorm_microarrayDir, "mexp3309_AMEXP2210_nonnormalized.Rds"))

#Normalized
mtab3309_norm <- limma::neqc(mtab3309_raw)

rownames(mtab3309_sdrf_filtered) <- colnames(mtab3309_norm)

norm_microarray_list$MTAB3309_AMEXP2210 <- ExpressionSet(assayData = mtab3309_norm$E,
                                                         phenoData = as(mtab3309_sdrf_filtered, "AnnotatedDataFrame"),
                                                         annotation = "AMEXP2210")

saveRDS(norm_microarray_list$MTAB3309_AMEXP2210, file.path(norm_microarrayDir, "mexp3309_AMEXP2210_normalized.Rds"))
```

#####Agilent

* `E-MEXP-2032`

The obtained `.sdrf` file of `E-MEXP-2032` does not get imported properly as the sample names are not unique. A quick investigation of the `.sdrf` file suggests that the entire table is inconsistent with the columns not always matching up. Some of the `Array.Data.File` entries have multiple experiments associated to one file with the metadata suggesting that the samples are likely the same, but run across two dyes (perhaps such an approach is done for technical replication purposes?). We fixed this by creating a new `.sdrf` file containing only the Cy5 entries. This new `.sdrf` file can be then be used as input for the  `ae2bioc()` function. 

```{r E-MEXP-2032_AAGIL28, results = "hide"}
mexp2032_path <- file.path(raw_microarrayDir, "EMEXP2032")

mexp2032_sdrf <- read.csv(file.path(mexp2032_path, "E-MEXP-2032.sdrf.txt"), sep = "\t", stringsAsFactors = F)

mexp2032_sdrf <- mexp2032_sdrf[which(mexp2032_sdrf$Label == "Cy5"),]

#Backup
if(!file.exists(file.path(mexp2032_path, "E-MEXP-2032.sdrf.txt.bak"))){
  file.copy(from = file.path(mexp2032_path, "E-MEXP-2032.sdrf.txt"), to = file.path(rawdata_dir, "EMEXP2032/E-MEXP-2032.sdrf.txt.bak"))
}
write.table(mexp2032_sdrf, file = file.path(mexp2032_path, "E-MEXP-2032.sdrf.txt"), sep = "\t") 

mexp2032_raw <- ae2bioc(mageFiles = microarray_ae_data$MEXP2032)

mexp2032_rg <- new("RGList", c(as.list(assayData(mexp2032_raw$`A-AGIL-28`)),
                               list(targets = pData(mexp2032_raw$`A-AGIL-28`),
                                    genes = fData(mexp2032_raw$`A-AGIL-28`))))

#No normalization
mexp2032_nonorm_ma <- limma::normalizeWithinArrays(mexp2032_rg, method = "none")
mexp2032_nonorm_ma <- mexp2032_nonorm_ma[mexp2032_nonorm_ma$genes$Control.Type == "", ]
table(table(mexp2032_nonorm_ma$genes$Reporter.Database.Entry.agilent_probe.))

mexp2032_nonorm_ma <- limma::avereps(x = mexp2032_nonorm_ma, ID = mexp2032_nonorm_ma$genes$Reporter.Database.Entry.agilent_probe.)
mexp2032_nonorm <- as(mexp2032_nonorm_ma, "ExpressionSet")
annotation(mexp2032_nonorm) <- "AAGIL28"

nonnorm_microarray_list$MEXP2032_AAGIL28 <- mexp2032_nonorm

saveRDS(nonnorm_microarray_list$MEXP2032_AAGIL28, file.path(nonnorm_microarrayDir, "mexp2032_AAGIL28_nonnormalized.Rds"))

#Normalized
mexp2032_ma <- limma::normalizeWithinArrays(mexp2032_rg, method = "loess")
mexp2032_ma <- mexp2032_ma[mexp2032_ma$genes$Control.Type == "", ]
table(table(mexp2032_ma$genes$Reporter.Database.Entry.agilent_probe.))

mexp2032_ma <- limma::avereps(x = mexp2032_ma, ID = mexp2032_ma$genes$Reporter.Database.Entry.agilent_probe.)
mexp2032_norm <- as(mexp2032_ma, "ExpressionSet")
annotation(mexp2032_norm) <- "AAGIL28"

norm_microarray_list$MEXP2032_AAGIL28 <- mexp2032_norm

saveRDS(norm_microarray_list$MEXP2032_AAGIL28, file.path(norm_microarrayDir, "mexp2032_AAGIL28_normalized.Rds"))
```

* `E-MTAB-5095`

Again, the obtained `.sdrf` file of `E-MTAB-5095`  does not get imported properly as the sample names are not unique, with duplicates of the same file labeled as either Cy3 and Cy5, which furthermore do not always correspond to the right number. Unlike  previous studies, the number of Cy3 and Cy5 files are not equal: some samples have been labelled with Cy3 and others with Cy5. We fixed this by sorting the `.sdrf` file according to the `label`, removing the duplicated `Array.Data.File` entries, and finally renaming all `Cy3` entries to `Cy5`.

```{r E-MTAB-5095_AMEXP2104, results = "hide"}
mtab5095_path <- file.path(raw_microarrayDir, "EMTAB5095")

mtab5095_pdata <- samples_microarray_ae[which(samples_microarray_ae$StudyID == "MTAB5095"),]
mtab5095_sdrf <- read.csv(file.path(mtab5095_path, "E-MTAB-5095.sdrf.bak"), sep = "\t", stringsAsFactors = F)
mtab5095_sdrf <- mtab5095_sdrf[order(mtab5095_sdrf$Label),]
mtab5095_sdrf <- mtab5095_sdrf[-which(duplicated(mtab5095_sdrf$Array.Data.File)),]
mtab5095_sdrf$Label <- "Cy5"

#Backup
if(!file.exists(file.path(mtab5095_path, "E-MTAB-5095.sdrf.txt.bak"))){
  file.copy(from = file.path(mtab5095_path, "E-MTAB-5095.sdrf.txt"), to = file.path(mtab5095_path, "E-MTAB-5095.sdrf.txt.bak"))
}
write.table(mtab5095_sdrf, file = file.path(mtab5095_path, "E-MTAB-5095.sdrf.txt"), sep = "\t", row.names = F)

mtab5095_raw <- ae2bioc(mageFiles = microarray_ae_data$MTAB5095)

mtab5095_elr <- new("EListRaw", c(as.list(assayData(mtab5095_raw)),
                                  list(targets = pData(mtab5095_raw),
                                       genes = fData(mtab5095_raw))))

#No normalization
mtab5095_nonorm <- nec(x = mtab5095_elr, status = mtab5095_elr$genes$ControlType, negctrl = -1, regular = 0)
mtab5095_nonorm$E <- log2(mtab5095_nonorm$E)

table(table(mtab5095_nonorm$genes$ProbeName))
mtab5095_nonorm$E <- avereps(mtab5095_nonorm$E, ID = mtab5095_nonorm$genes$ProbeName)
rownames(mtab5095_nonorm$targets) <- gsub("\\.txt", "", rownames(mtab5095_nonorm$targets))

nonnorm_microarray_list$MTAB5095_AMEXP2104 <- ExpressionSet(assayData = mtab5095_nonorm$E,
                                                            phenoData = as(mtab5095_nonorm$targets, "AnnotatedDataFrame"),
                                                            annotation = "AMEXP2104")

saveRDS(nonnorm_microarray_list$MTAB5095_AMEXP2104, file.path(nonnorm_microarrayDir, "mtab5095_AMEXP2104_nonnormalized.Rds"))

#Normalized
mtab5095_norm <- neqc(x = mtab5095_elr, status = mtab5095_elr$genes$ControlType, negctrl = -1, regular = 0)
table(table(mtab5095_norm$genes$ProbeName))
mtab5095_norm <- avereps(mtab5095_norm, ID = mtab5095_norm$genes$ProbeName)
rownames(mtab5095_norm$targets) <- gsub("\\.txt", "", rownames(mtab5095_norm$targets))

norm_microarray_list$MTAB5095_AMEXP2104 <- ExpressionSet(assayData = mtab5095_norm$E,
                                                         phenoData = as(mtab5095_norm$targets, "AnnotatedDataFrame"),
                                                         annotation = "AMEXP2104")

saveRDS(norm_microarray_list$MTAB5095_AMEXP2104, file.path(norm_microarrayDir, "mtab5095_AMEXP2104_normalized.Rds"))
```

After importing everything, we will have two extra dataseries in the normalized data because the raw data was not available.

```{r check the imported data}
length(norm_microarray_list)
length(nonnorm_microarray_list)

lapply(norm_microarray_list, function(eset) head(exprs(eset)))
```

```{r save the normalized and non-normalized data, results = "hide"}
saveRDS(nonnorm_microarray_list, file.path(nonnorm_microarrayDir, "nonnorm_microarray_list.Rds"))
saveRDS(norm_microarray_list, file.path(norm_microarrayDir, "norm_microarray_list.Rds"))
```

###Reannotation and aggregation

Having imported all the (non-)normalized data previously we will now have to reannotate the probes to a common identifier. As we are dealing with different types of microarrays, we are limited to the lowest resolution, which is gene-level information. This is because not all included microarray platforms measure transcripts. Luckily, most annotation files provided by the manufacturer's provide annotations to a gene identifier (e.g. Ensembl, Entrez, RefSeq) as well. However, this is not always the same gene identifier. However, this gene identifier can subsequently be converged onto a common identifier. We opted to converge onto the Entrez gene identifier as it appears that most microarrays had included Entrez gene identifiers.

```{r reannotation and aggregation setup, results = "hide"}
require(parallel)
require(biomaRt)

#annotation identifiers
anno_ids <- unlist(lapply(norm_microarray_list, annotation))
gpl_ids <- unique(anno_ids[grep("GPL", anno_ids)])
adf_ids <- unique(anno_ids[-grep("GPL", anno_ids)])

#store all the annotations in a list
microarray_annotations_converged <- list()
annoDir <- file.path(microarrayDir, "annotations")
dir.create(annoDir)

ensembl <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

#Reannotate the Ensembl Gene IDs to Entrez IDs
ENS_Entrez_dict <- getBM(attributes = c("ensembl_gene_id", "entrezgene"), mart = ensembl)
#Reannotate the RefSeq IDs to Entrez IDs
RefSeq_Entrez_dict <- getBM(attributes = c("refseq_mrna", "entrezgene"), mart = ensembl)
#Reannotate the Gene Symbols to Entrez IDs
Genbank_Entrez_dict <- getBM(attributes = c("embl", "entrezgene"), mart = ensembl)

IDconverter <- function(probeID, geneID, geneID_type){
  #This auxiliary function will be used to convert probe IDs to Entrez IDs.
  
  #probeID: Vector of length n comprising the probe IDs (the available ID)
  #geneID: Vector of length n comprising the gene IDs  (the ID to be converted to)
  #geneID_type: Character either "Entrez", "Ensembl" or "RefSeq"
  
  geneID_type <- toupper(geneID_type)
  
  ID_df <- data.frame(probeID = probeID, geneID = geneID)
  
  #Remove the probes that are not annotated to a uniform identifier
  ID_df_culled <- ID_df[which(!is.na(ID_df$geneID)), ]
  ID_df_culled <- ID_df[which(ID_df$geneID != ""), ]
  
  if(geneID_type == "REFSEQ"){
    #If the geneID_type is RefSeq, find the entries that start with "N" as these represent known entries
    ID_df_RefSeq <- strsplit(x = as.character(ID_df_culled$geneID), split = "(,|;)")
    ID_df_RefSeq <- lapply(X = ID_df_RefSeq, FUN = function(RefSeq){
      unique(RefSeq[grep("^N.+", RefSeq)])
    })
    
    no_cores <- detectCores()-2
    cl <- makeCluster(no_cores)
    clusterExport(cl = cl, varlist = c("RefSeq_Entrez_dict"))
  
    Entrez <- parLapply(cl = cl, X = ID_df_RefSeq, fun = function(entry){
      unlist(lapply(entry, function(RefSeq){
        RefSeq_Entrez_dict$entrezgene[grep(paste0("^", RefSeq, "$"), RefSeq_Entrez_dict$refseq_mrna)]
      }))
    })
    stopCluster(cl = cl)
    
  } else if(geneID_type == "ENSEMBL"){
    #Replace "///" with ";", for some reason, the strsplit() function cannot cope with regex
    ID_df_culled$geneID <- gsub(pattern = " (\\/\\/\\/|,) ", replacement = ";", x = ID_df_culled$geneID)
    ID_df_ENS <- strsplit(x = as.character(ID_df_culled$geneID), split = ";")
    
    no_cores <- detectCores()-2
    cl <- makeCluster(no_cores)
    clusterExport(cl = cl, varlist = c("ENS_Entrez_dict"))

    Entrez <- parLapply(cl = cl, X = ID_df_ENS, fun = function(entry){
      unlist(lapply(entry, function(ENS){
        ENS_Entrez_dict$entrezgene[grep(paste0("^", ENS, "$"), ENS_Entrez_dict$ensembl_gene_id)]
      }))
    })
    stopCluster(cl = cl)
    
  } else if(geneID_type == "GENBANK"){
    ID_df_culled$geneID <- gsub(pattern = " (\\/\\/\\/|,) ", replacement = ";", x = ID_df_culled$geneID)
    ID_df_GB <- strsplit(x = as.character(ID_df_culled$geneID), split = ";")
    
    no_cores <- detectCores()-2
    cl <- makeCluster(no_cores)
    clusterExport(cl = cl, varlist = c("Genbank_Entrez_dict"))

    Entrez <- parLapply(cl = cl, X = ID_df_GB, fun = function(entry){
      unlist(lapply(entry, function(GB){
        Genbank_Entrez_dict$entrezgene[grep(paste0("^", GB, "$"), Genbank_Entrez_dict$embl)]
      }))
    })
    stopCluster(cl = cl)
    
  } else if(geneID_type == "ENTREZ"){
    ID_df_culled$geneID <- gsub(pattern = " (\\/\\/\\/|,) ", replacement = ";", x = ID_df_culled$geneID)
    # ID_df_Entrez <- strsplit(x = as.character(ID_df_culled$geneID), split = ";")
    # 
    # Entrez <- ID_df_Entrez[[1]]
    Entrez <- ID_df_culled$geneID
  } else{
    stop("geneID_type is unknown")
  }

  #Find the probes that have several annotations.
  table(unlist(lapply(Entrez, length)))
  
  Entrez_collapsed <- unlist(lapply(Entrez, function(entry){paste(entry, collapse = ";")}))
  ID_Entrez <- unique(data.frame(ID = as.character(ID_df_culled$probeID), Entrez = as.character(Entrez_collapsed)))
  
  which(table(microarray_annotations_converged$AAGIL28$ID) > 1)
  
  return(ID_Entrez)
}
```

####Reannotation

#####Gene Expression Omnibus

GEO annotations are stored in the `gpl[0-9]+.soft` files.

```{r geo annotations import, results = "hide"}
gpl_files <- file.path(raw_microarrayDir, paste0(gpl_ids, ".soft"))

geo_annotations <- lapply(gpl_files, FUN = function(soft){
  Table(getGEO(filename = soft))
})

names(geo_annotations) <- gpl_ids
```

```{r check geo annotations}
lapply(geo_annotations, head)
```

* `GPL10739`
This microarray contains 257430 probes, 241656 of which associate to known genes. 

```{r GPL10739, hide = "results"}
microarray_annotations_converged$GPL10739 <- IDconverter(probeID = geo_annotations$GPL10739$ID, geneID = geo_annotations$GPL10739$GB_LIST, geneID_type = "REFSEQ")
```

* `GPL96`
This microarray contains 22283 probes, 20973 of which associate to known genes. 

```{r GPL96, hide = "results"}
microarray_annotations_converged$GPL96 <- IDconverter(probeID = geo_annotations$GPL96$ID, geneID = geo_annotations$GPL96$ENTREZ_GENE_ID, geneID_type = "ENTREZ")
```

* `GPL13158`
This microarray contains 54715 probes, 41791 of which associate to known genes. 

```{r GPL13158, hide = "results"}
microarray_annotations_converged$GPL13158 <- IDconverter(probeID = geo_annotations$GPL13158$ID, geneID = geo_annotations$GPL13158$ENTREZ_GENE_ID, geneID_type = "ENTREZ")
```

* `GPL6947`
This microarray contains 49576 probes, 35280 of which associate to known genes. 

```{r GPL6947, hide = "results"}
microarray_annotations_converged$GPL6947 <- IDconverter(probeID = geo_annotations$GPL6947$ID, geneID = geo_annotations$GPL6947$Entrez_Gene_ID, geneID_type = "ENTREZ")
```

* `GPL6102`
This microarray contains 48702 probes, 30542 of which associate to known genes. 

```{r GPL6102, hide = "results"}
microarray_annotations_converged$GPL6102 <- IDconverter(probeID = geo_annotations$GPL6102$ID, geneID = geo_annotations$GPL6102$Entrez_Gene_ID, geneID_type = "ENTREZ")
```

* `GPL13497`
This microarray contains 34184 probes, 29833 of which associate to known genes. 

```{r GPL13497, hide = "results"}
microarray_annotations_converged$GPL13497 <- IDconverter(probeID = geo_annotations$GPL13497$ID, geneID = geo_annotations$GPL13497$GENE, geneID_type = "ENTREZ")
```

* `GPL6480`
This microarray contains 41108 probes, 30936 of which associate to known genes. 

```{r GPL6480, hide = "results"}
microarray_annotations_converged$GPL6480 <- IDconverter(probeID = geo_annotations$GPL6480$ID, geneID = geo_annotations$GPL6480$GENE, geneID_type = "ENTREZ")
```

* `GPL17077`
This microarray contains 50739 probes, 29833 of which associate to known genes. 

```{r GPL17077, hide = "results"}
microarray_annotations_converged$GPL17077 <- IDconverter(probeID = geo_annotations$GPL17077$ID, geneID = geo_annotations$GPL17077$LOCUSLINK_ID, geneID_type = "ENTREZ")
```

* `GPL570`
This microarray contains 54675 probes, 44134 of which associate to known genes. 

```{r GPL570, hide = "results"}
microarray_annotations_converged$GPL570 <- IDconverter(probeID = geo_annotations$GPL570$ID, geneID = geo_annotations$GPL570$ENTREZ_GENE_ID, geneID_type = "ENTREZ")
```

* `GPL8300`
This microarray contains 12625 probes, 12119 of which associate to known genes. 

```{r GPL8300, hide = "results"}
microarray_annotations_converged$GPL8300 <- IDconverter(probeID = geo_annotations$GPL8300$ID, geneID = geo_annotations$GPL8300$ENTREZ_GENE_ID, geneID_type = "ENTREZ")
```

* `GPL8432`
This microarray contains 29187 probes, 26503 of which associate to known genes. 

```{r GPL8432, hide = "results"}
microarray_annotations_converged$GPL8432 <- IDconverter(probeID = geo_annotations$GPL8432$ID, geneID = geo_annotations$GPL8432$Entrez_Gene_ID, geneID_type = "ENTREZ")
```

* `GPL10558`
This microarray contains 48107 probes, 43960 of which associate to known genes. 

```{r GPL10558, hide = "results"}
microarray_annotations_converged$GPL10558 <- IDconverter(probeID = geo_annotations$GPL10558$ID, geneID = geo_annotations$GPL10558$Entrez_Gene_ID, geneID_type = "ENTREZ")
```

* `GPL15207`
This microarray contains 29187 probes, 26503 of which associate to known genes. 

```{r GPL15207, hide = "results"}
microarray_annotations_converged$GPL15207 <- IDconverter(probeID = geo_annotations$GPL15207$ID, geneID = geo_annotations$GPL15207$'Entrez Gene', geneID_type = "ENTREZ")
```

#####ArrayExpress

ArrayExpress annotations are saved within the folder of an experiment itself, in the form of an `.adf.txt` file. One problem in importing the `.adf.txt` files pertain the initial comments. Due to the fact that some headers do not contain sufficient tabs after the comment section, R will mistakenly believe that the matrix has less columns that expected. To circumvent this issue, import only after the `[main]` strings has been observed.

```{r ArrayExpress annotations import, results = "hide"}
ae_files <- file.path(raw_microarrayDir, paste0("E", studies_microarray_ae))

adf_files <- unlist(lapply(ae_files, function(ae){
  list.files(ae, full.names = T)[grep(".+\\.adf\\.txt", list.files(ae))]
}))

#Remove A-AGIL-11 because we don't want that particular array
adf_files <- adf_files[-grep("A-AGIL-11", adf_files)]
adf_files <- adf_files[!duplicated(gsub(".+(A-.+)\\.adf\\.txt", "\\1", adf_files))]

adf_names <- gsub("^.+(A-.+)\\.adf\\.txt", "\\1", adf_files)
adf_names <- gsub("-", "", adf_names)

adf_importer <- function(adf){
  skip_lines <- grep("\\[main\\]", readLines(adf))
  read.csv(adf, skip = skip_lines, sep = "\t")
}

ae_annotations <- lapply(X = adf_files, FUN = adf_importer)
names(ae_annotations) <- adf_names
```

```{r check ae annotations}
lapply(ae_annotations, head)
```

* `AAGIL28`
This microarray contains 45220 probes, 26347 of which associate to known genes. 

```{r AAGIL28, results = "hide"}
microarray_annotations_converged$AAGIL28 <- IDconverter(probeID = ae_annotations$AAGIL28$Reporter.Name, geneID = ae_annotations$AAGIL28$Composite.Element.Database.Entry.refseq., geneID_type = "REFSEQ")
```

* `AMEXP2104`
This microarray contains 62976 probes, 46167 of which associate to known genes. 

```{r AMEXP2104, results = "hide"}
microarray_annotations_converged$AMEXP2104 <- IDconverter(probeID = ae_annotations$AMEXP2104$Reporter.Name, geneID = ae_annotations$AMEXP2104$Reporter.Database.Entry.entrez., geneID_type = "ENTREZ")
```

* `AMEXP2210`
This microarray contains 47231 probes, 43960 of which associate to known genes. 

```{r AMEXP2210, results = "hide"}
microarray_annotations_converged$AMEXP2210 <- IDconverter(probeID = ae_annotations$AMEXP2210$Reporter.Name, geneID = ae_annotations$AMEXP2210$Reporter.Database.Entry.entrez., geneID_type = "ENTREZ")
```

* `AAFFY44`
This microarray contains 54675 probes, 32408 of which associate to known genes. 

```{r AAFFY44, results = "hide"}
microarray_annotations_converged$AAFFY44 <- IDconverter(probeID = ae_annotations$AAFFY44$Composite.Element.Name, geneID = ae_annotations$AAFFY44$Composite.Element.Database.Entry.refseq., geneID_type = "REFSEQ")
```

```{r annotations check and save the data}
lapply(microarray_annotations_converged, function(study){table(table(study$ID))})

table(unique(unlist(lapply(norm_microarray_list, annotation))) %in% names(microarray_annotations_converged))

saveRDS(microarray_annotations_converged, file.path(annoDir, "microarray_annotations_converged.Rds"))
```

####Aggregation

Previously we imported the various microarray datasets and stored them in two separate lists: one list for the normalized and the other list for the non-normalized `ExpressionSets`. We then processed the annotation files to create a dictionary to map each probe ID to its Entrez gene ID. In the following section we will be combining the expression data and their new annotations. We will encounter two situations that will need to be dealt with accordingly: 
1) some probes will associate to multiple genes, and 
2) some genes will be represented by multiple probes. 
In case of the issue 1), those probes will need to be removed as they could represent promiscuous probes that might cloud our analyses later on. In case of issue 2), we will aggregate by taking the median of the probes that associate to the same gene to make use of the additional information. 
  An important aspect to take note of is that certain microarray platforms (i.e. GeneChip [Human Exon 1.0 ST Array](https://www.thermofisher.com/order/catalog/product/900651)) were specifically designed to bind exons resulting in multiple probes for some genes. In fact, every single probe will associate to a (set of) exon(s), which means that depending on the microarray design, observed differences might simply be due to differential transcript usage. As most of our included microarrays were gene-based microarrays, we aggregated all probes to the gene level in an effort to find consensus patterns across studies. We acknowledge that idealistically speaking all microarray probes would have been targeting specific exons.

#####Quality control microarrays

Prior to aggregation, we will perform quality control to ensure that probes/samples of questionable quality are removed that would otherwise be aggregated into the final signal. First we will gauge the quality using the `arrayQualityMetrics` package. Note that `arrayQualityMetrics` stores its output into a separate folder that contains all the data. We specifically paid attention to the MA and PCA plots for outlier samples within the same group. An interesting observation we made was that the `GEOquery` and `arrayQualityMetrics` cannot be loaded in the same workspace as `arrayQualityMetrics`, as the former imports a function with the same name as a function present in  `GEOquery`. Second, we will need to remove probes of bad quality. The easiest implementation we found was the `goodSamplesGenes` function from `WGCNA`. Note that for the quality control, we use the normalized data after which we perform the same operations on the non-normalized data.

```{r quality control step 1, results = "hide"}
awg_wrapper <- function(eset, name){
  arrayQualityMetrics::arrayQualityMetrics(expressionset = eset,
                                           outdir = file.path(qc_dir, name))
}

#mapply(FUN = awg_wrapper, eset = norm_microarray_list, name = names(norm_microarray_list)) #I commented out the function to run `arrayQualityMetrics` as it takes a long time to run.
```

Second, we use `WGCNA` to extract the good probes. 

```{r quality control step 2, results = "hide"}
wgcna_qc <- function(exprSet){
  expr_values <- exprs(exprSet)
  
  qc <- WGCNA::goodSamplesGenes(t(expr_values), minNSamples = ncol(expr_values))
  exprset_qc <- exprSet[qc$goodGenes, qc$goodSamples]
}

norm_microarray_qc <- lapply(X = norm_microarray_list, FUN = wgcna_qc)
```

```{r check quality, fig.width = 7.5, fig.height = 7.5}
ceil_studies <- ceiling(sqrt(length(norm_microarray_qc)))

#Cairo(file = file.path(qcDir, "norm_microarray_density.pdf"), type = "pdf", units = "px", width = 1500, height = 1500, dpi = 90, bg = "white")
par(mfrow = c(ceil_studies, ceil_studies))
for(i in 1:length(norm_microarray_qc)){
  hist(norm_microarray_qc[[i]], 
       xlim = c(-10, 20), 
       xlab = "Exprs",
       main = names(norm_microarray_qc[i]))
}
#dev.off()
```

```{r nonnormalized quality control, results = "hide"}
ps_extracter <- function(eset_qc, eset_raw){
  eset_raw[rownames(eset_qc), colnames(eset_qc)]
}

nonnorm_microarray_qc <- mapply(FUN = ps_extracter, eset_qc = norm_microarray_qc[names(nonnorm_microarray_list)], eset_raw = nonnorm_microarray_list)
```

Having performed the quality control, the next steps are the removal of promiscuous probe and the merging of probes belonging to the same gene. The first step would be to investigate how pervasive the promiscuous probes are. We note that the annotation could sometimes be a little misleading with multiple Entrez IDs actually referring to the same gene but having multiple IDs. Unfortunately our current strategy is to remove them as we have found no satisfactory way of distinguishing between them. 

Promiscuous probes would be annotated with several Entrez gene IDs. An easy way to figure out which probes are promiscuous is by looking for the `;`, which was used as a delimiter in case multiple genes were associated. 

```{r promiscuous probe counting}
lapply(microarray_annotations_converged, function(study){length(grep(";", study$Entrez))})
```

```{r remove promiscuous probes, results = "hide"}
prom_probe_remover <- function(entrez_probes){
  entrez_probes$Entrez <- as.character(entrez_probes$Entrez)
  rownames(entrez_probes) <- entrez_probes$ID
  genes_filtered <- entrez_probes[grep("(;|^$)", as.character(entrez_probes$Entrez), invert = T), ]
  return(genes_filtered)
}

microarray_annotations_converged_noprom <- lapply(X = microarray_annotations_converged, FUN = prom_probe_remover)
```

Now we will aggregate the probes associated to the same gene ID and annotate them accordingly. In addition, the samples of interest are extracted to facilitate downstream analyses. In the next chunk we perform some parallel computations, if you were trying to repeat the computations, either adjust the parallelization to the resources you have available, or rewrite the function to serialize it.

```{r merge probes associated to same Entrez gene ID, results = "hide"}
require(dplyr)
require(reshape)

microarray_merger <- function(study_name, eset_filtered_qc, microarray_annotations_converged_noprom, phenosheet_unique_split){
  #This function will extract the samples of interest as found in the phenosheet and take the median of the probes associating to the same Entrez gene ID.
  
  #study_name: Study ID with an appended platform ID
  #eset_filtered_qc: List of expressionSet objects that have been filtered
  #microarray_annotations_converged_noprom: List of microarray annotations where all promiscuous probes have been removed
  #phenosheet_unique_split: List of phenosheets split by study and platform
  
  anno_name <- gsub("^.+_(.+$)", "\\1", study_name)
  
  study_entrez <- microarray_annotations_converged_noprom[[anno_name]]
  eset_data_qc <- eset_filtered_qc[[study_name]]

  #Samples of interest
  samples <- phenosheet_unique_split[[study_name]]
  samples$SampleID <- gsub("-", ".", samples$SampleID)
  rownames(samples) <- samples$SampleID
  
  #Find the probes that were annotated using Ensembl Gene IDs
  eset_data_filtered <- eset_data_qc[which(rownames(eset_data_qc) %in% rownames(study_entrez)), ]
  exprs_data_filtered <- data.frame(exprs(eset_data_filtered), entrez_gene = study_entrez[rownames(eset_data_filtered), "Entrez"])
  
  #Take the median of the probes that bind the same Ensembl Gene ID
  exprs_data_merged <- cast(melt(exprs_data_filtered, id.vars = "entrez_gene"), entrez_gene ~ variable, median)
  exprs_data_merged <- as.matrix(data.frame(exprs_data_merged, row.names = 1))
  
  colnames(exprs_data_merged) <- gsub("-", ".", colnames(exprs_data_merged))
  exprs_data_merged <- exprs_data_merged[, rownames(samples)]
  
  #Make new expressionSet
  eset_data_merged <- ExpressionSet(assayData = exprs_data_merged, 
                                    phenoData = new("AnnotatedDataFrame", data = samples),
                                    annotation = annotation(eset_data_qc))
  return(eset_data_merged)
}

no_cores <- detectCores() - 10
cl <- makeCluster(no_cores)
clusterEvalQ(cl = cl, expr = c(library(Biobase), 
                               library(reshape)))

#Normalized macrophages
norm_microarray_merged <- parLapply(cl = cl, 
                                    X = names(norm_microarray_qc), 
                                    fun = microarray_merger, 
                                    eset_filtered_qc = norm_microarray_qc, 
                                    microarray_annotations_converged_noprom = microarray_annotations_converged_noprom, 
                                    phenosheet_unique_split = samples_microarray_split)
names(norm_microarray_merged) <- names(norm_microarray_qc)

#Non-normalized macorphages
nonnorm_microarray_merged <- parLapply(cl = cl, 
                                       X = names(nonnorm_microarray_qc), 
                                       fun = microarray_merger, 
                                       eset_filtered_qc = nonnorm_microarray_qc, 
                                       microarray_annotations_converged_noprom = microarray_annotations_converged_noprom,
                                       phenosheet_unique_split = samples_microarray_split)
names(nonnorm_microarray_merged) <- names(nonnorm_microarray_qc)
stopCluster(cl)

saveRDS(norm_microarray_merged, file.path(rdataDir, "normalized_converged_microarrays.Rds"))
saveRDS(nonnorm_microarray_merged, file.path(rdataDir, "nonnormalized_converged_microarrays.Rds"))
```

```{r check post merge pdata}
lapply(norm_microarray_merged, function(eset){table(pData(eset)$Group)})
```

```{r comparison pre and post merge}
reannotation_qc <- function(eset_preqc, eset_postqc){
  c(dim(eset_preqc), dim(eset_postqc))
}

microarray_merge_stats <- t(mapply(FUN = reannotation_qc, eset_preqc = norm_microarray_list, eset_postqc = norm_microarray_merged))
colnames(microarray_merge_stats) <- c("nrow_pre", "ncol_pre", "nrow_post", "ncol_post")
write.csv(microarray_merge_stats, file.path(qcDir, "microarray_merge_statistics.csv"))
```

##RNAseq

In this section we will import the RNAseq counts. We assume that you have already performed the read alignment and the counting. The data of the aforementioned steps are expected to be stored in the `rnaseq` data directory.

```{r setup rnaseq preprocessing, results = "hide"}
rnaseqDir <- file.path(dataDir, "rnaseq")
countDir <- file.path(rnaseqDir, "raw")
```

###Reads preprocessing

We annotated the data according to the Gencode annotations, which is basically the Ensembl annotation with an appended number. However, our data needs to be annotated with Entrez to keep consistent with the microarray data. We will therefore perform some translation using `biomaRt`.

```{r import rnaseq reads, results = "hide"}
rnaseq_counts_raw <- list(
  BLUEPRINT = read.csv(file.path(countDir, "BLUEPRINT", "counts.txt"), sep = "\t", stringsAsFactors = F, skip = 1)[, -c(2,3,4,5,6)],
  GSE100382 = read.csv(file.path(countDir, "GSE100382", "counts.txt"), sep = "\t", stringsAsFactors = F, skip = 1)[, -c(2,3,4,5,6)],
  GSE55536 = read.csv(file.path(countDir, "GSE55536", "counts.txt"), sep = "\t", stringsAsFactors = F, skip = 1)[, -c(2,3,4,5,6)],
  GSE80727 = read.csv(file.path(countDir, "GSE80727", "counts.txt"), sep = "\t", stringsAsFactors = F, skip = 1)[, -c(2,3,4,5,6)],
  GSE82227 = read.csv(file.path(countDir, "GSE82227", "counts.txt"), sep = "\t", stringsAsFactors = F, skip = 1)[, -c(2,3,4,5,6)],
  exp068 = read.csv(file.path(countDir, "own", "counts.txt"), sep = "\t", stringsAsFactors = F, skip = 1)[, -c(2,3,4,5,6)]
)

rnaseq_counts_proc <- lapply(rnaseq_counts_raw, function(counts){
  colnames(counts) <- gsub("^.+GSE[0-9]+..(GSM[0-9]+).bam$", "\\1", colnames(counts))
  colnames(counts) <- gsub("^.+(exp068.+).bam$", "\\1", colnames(counts))
  colnames(counts) <- gsub("^(EGAZ[0-9]+).+.bam$", "\\1", colnames(counts))
  rownames(counts) <- gsub("(ENSG[0-9]+)\\.[0-9]+", "\\1", counts$Geneid)
  return(counts[,-1])
})
```

Due to the translation from Gencode to Entrez, some reads might be associated to the same gene. To this end, we take the sum of all  reads annotated to the same Entrez gene ID. Note that our workflow might have introduced a minor flaw where we miss some reads. We previously counted the reads using `featureCount` where we ignored reads that multimapped across several features. This might have lead to the case where we ignore reads that were allocated to different Gencode features, but which are the same Entrez gene feature. 

```{r aggregating reads, results = "hide"}
ensembl2entrezmerger <- function(counts){
  #This function will aggregate the reads mapping to the same Entrez gene ID by taking the sum and will reannotate the reads according to the Entrez gene ID.
  
  counts <- data.frame(counts, Geneid = rownames(counts))
  counts_entrez <- merge(x = ENS_Entrez_dict, y = counts, by.x = "ensembl_gene_id", by.y = "Geneid")[,-1]
  counts_entrez <- aggregate(formula = . ~ entrezgene, data = counts_entrez, FUN = sum)
  rownames(counts_entrez) <- counts_entrez$entrezgene
  counts_entrez <- counts_entrez[,-1]
  return(counts_entrez)
}

rnaseq_counts_entrez <- lapply(rnaseq_counts_proc, ensembl2entrezmerger)

saveRDS(object = rnaseq_counts_entrez, file = file.path(rdataDir, "raw_converged_rnaseq.Rds"))
```

Having aggregated the reads, we would want to normalize the reads for the library size to correct for the total number of reads per sample. This can be done reasonably easily with the `edgeR` package. To this end, we will import the data as a `DGEList`, which represents an object akin to the `expressionSet` used for the microarrays where all relevant data (i.e. count and sample information) are stored in one object.

Based on `FastQC`, we found that the following samples failed quality control:
- GSM2135456
- GSM2135457
- GSM2135458
- GSM2135459
- GSM2135477
- GSM2135478
- GSM2135479
- GSM2135480
- GSM2135481
- GSM2135482
- EGAZ00001019361
As such, we will remove them from the study.

```{r rnaseq sample removal, results = "hide"}
bad_rnaseq_samples <- c("GSM2135456", 
                        "GSM2135457", 
                        "GSM2135458", 
                        "GSM2135459", 
                        "GSM2135477", 
                        "GSM2135478", 
                        "GSM2135479", 
                        "GSM2135480", 
                        "GSM2135481", 
                        "GSM2135482", 
                        "EGAZ00001019361")

#Removal from samplesheet
samples_rnaseq_culled <- samples_rnaseq[!samples_rnaseq$SampleID %in% bad_rnaseq_samples,]
samples_rnaseq_culled_split <- split(samples_rnaseq_culled, samples_rnaseq_culled$StudyID)
samples_rnaseq_culled_split <- samples_rnaseq_culled_split[names(rnaseq_counts_entrez)]

#Removal from counts
rnaseq_counts_culler <- function(counts, samples){
  counts[, samples$SampleID]
}

rnaseq_counts_culled <- mapply(rnaseq_counts_culler, counts = rnaseq_counts_entrez, samples = samples_rnaseq_culled_split)
```

```{r edgeR setup, results = "hide"}
require(edgeR)

edger_prep <- function(counts, samples){
  dgList <- DGEList(counts = counts, 
                    samples = samples)
  dgList$samples$lib.size <- colSums(dgList$counts)
  #Remove genes with low CPM
  dgList <- dgList[rowSums(cpm(dgList) > 1) >= 2, , keep.lib.sizes=FALSE]
  #Normalization
  dgList <- calcNormFactors(dgList)
  return(dgList)
}

rnaseq_dglists <- mapply(FUN = edger_prep, counts = rnaseq_counts_culled, samples = samples_rnaseq_culled_split, SIMPLIFY = F)

saveRDS(rnaseq_dglists, file.path(rdataDir, "raw_rnaseq_dglist.Rds"))
```

#Meta-analysis

As described previously, we will utilize the normalized data for the meta-analysis. For this particular analysis, we only need the samples belonging to the `Meta-analysis` cohort in the samplesheet. In a meta-analysis, we compare the effect size across studies. Specifically, we will be investigating whether effect sizes observed when comparing each macrophage subset with M0 is consistent across the different studies. To this end, we must calculate a standardized effect size which takes the effect size and the associated variance into consideration. A metric that is often used in meta-analyses is the Cohen d. For our analysis, we used the `GeneMeta` package, which implements the formulas as described in [Choi et al. 2003](10.1093/bioinformatics/btg1010). Given that we have a lot of contrasts to build, the default `GeneMeta` package would be slightly tedious to work with. Instead, we created some wrappers for some of the `GeneMeta` functions to allow for `lists` to be used as input. Furthermore, we replaced the t-statistic used by GeneMeta with the moderated t-statistic from `eBayes`. After all the aforementioned calculations, we define genes to be consistently differentially expressed (cDEGs) if their Benjamini-Hochberg adjusted *p*-value lies below the 0.05.
On thing to consider is that we are dealing with gene expression data from different sources. We will therefore not be measuring the same set of genes in every single study. As we are actually performing 7 separate meta-analyses, we will have to find the genes that are measured in all studies per comparison. 
First, we will define a wrapper function that performs the aforementioned operations. 

```{r meta-analysis functions, results = "hide"}
require(GeneMeta)

meta_regressor <- function(fit_list, contrast, studies_of_interest, nCTRL_list, nCASE_list, eBayes = T, gene_symbol = T, ...){
  #This function will perfor the meta-analysis using a list of "fit" objects, derived either from limma or edgeR. As some studies have included multiple comparisons, we must also provide a contrast, the studies of interest, a list of the reference group (nCTRL) and the case group (nCASE). 
  
  fits_of_interest <- fit_list[studies_of_interest]
  
  no_studies <- length(studies_of_interest)
  
  #Extract overlapping genes
  overlapping_genes <- unlist(Reduce(intersect, lapply(studies_of_interest, function(study){
    rownames(fits_of_interest[[study]])
  })))
  
  meta_stats <- function(study, fit_list, nCTRL_list, nCASE_list, contrast, overlapping_genes, eBayes){
    fit <- fit_list[[study]]
    nCTRL <- nCTRL_list[[study]]
    nCASE <- nCASE_list[[study]]
    
    if(class(fit) == "DGEGLM"){
      fit_class <- "edgeR"
    } else if(class(fit) == "MArrayLM"){
      fit_class <- "limma"
    }
    
    #Estimator of effect size using the empirical Bayes adjusted standard deviations (s2.post for limma and var.post for edgeR)
    if(class(fit) == "DGEGLM"){
      ifelse(eBayes, 
             cohend <- fit$coefficients[, contrast]/sqrt(fit$var.post),
             cohend <- fit$unshrunk.coefficients[, contrast]/sqrt(var.prior)
      )
    } else if(class(fit) == "MArrayLM"){
      ifelse(eBayes, 
             cohend <- fit$coefficients[, contrast]/sqrt(fit$s2.post),
             cohend <- fit$coefficients[, contrast]/fit$sigma
      )
    }
    
    #Unbiased estimator of effect size
    hedgesg <- dstar(d = cohend, n = (as.numeric(nCTRL) + as.numeric(nCASE)))
    hedgesg_var <- sigmad(d = hedgesg, ng1 = nCTRL, ng2 = nCASE)
    
    return(cbind(d = cohend[overlapping_genes], g = hedgesg[overlapping_genes], gvar = hedgesg_var[overlapping_genes]))
  }
  
  intermediate_stats <- lapply(X = studies_of_interest, FUN = meta_stats, fit = fits_of_interest, nCTRL = nCTRL_list, nCASE = nCASE_list, contrast = contrast, overlapping_genes = overlapping_genes, eBayes = eBayes)
  
  names(intermediate_stats) <- studies_of_interest
  
  cohends <- sapply(X = intermediate_stats, FUN = function(study){study[, "g"]}, simplify = T)
  cohends_vars <- sapply(X = intermediate_stats, FUN = function(study){study[, "gvar"]}, simplify = T)
  
  #Calculate the measure of heterogeneity across studies Cochran Q
  cochranQs <- f.Q(dadj = cohends, varadj = cohends_vars)
  
  #Plot Cochran Q against the chi-squared distribution with n-1 df
  chisqdf <- no_studies-1
  Q_chisq_df <- melt(cbind(cochranQ = cochranQs, chisq = rchisq(length(cochranQs), chisqdf)))
  colnames(Q_chisq_df) <- c("EntrezID", "Type", "Value")
  
  distr_plot <- ggplot(Q_chisq_df, aes(x = Value, col = Type)) + 
    geom_density() + 
    theme_bw() +
    ggtitle(paste0("Cochran Q against chisq (df = ", chisqdf, ")"))
  
  #Plot a QQ plot
  chisqq <- qchisq(seq(0, 0.9999, 0.001), df = chisqdf)
  cochranQsq <- quantile(cochranQs, seq(0, 0.9999, 0.001))
  
  chi_df <- data.frame(quantiles = chisqq, sampleqs = cochranQsq)
  max_plot <- round(max(chi_df)/10)*10
  
  qq_plot <- ggplot(chi_df, aes(x = quantiles, y = sampleqs)) +
    geom_point() +
    geom_line() +
    geom_abline(intercept = 0, color = "blue", linetype = "dotted") +
    xlim(0, max_plot) +
    ylim(0, max_plot) +
    ggtitle("Quantile-Quantile plot") +
    theme_bw()
  
  print(grid.arrange(distr_plot, qq_plot, ncol=2))
  
  #Estimated effect size corrected for heterogeneity using a random effects model
  DL_taus <- tau2.DL(Q = cochranQs, num.studies = no_studies, my.weights = 1/cohends_vars)
  
  cohends_vars_rem <- cohends_vars + DL_taus
  
  mus <- mu.tau2(my.d = cohends, my.vars.new = cohends_vars_rem)
  mus_vars <- var.tau2(cohends_vars_rem)
  
  #Z-statistic
  Zs <- mus/sqrt(mus_vars)
  Zpvals <- 2*pnorm(-abs(Zs))
  
  colnames(cohends) <- paste0(colnames(cohends), "_d")
  colnames(cohends_vars) <- paste0(colnames(cohends_vars), "_var")
  
  #Summarize everything in a dataframe
  results <- data.frame(cohends, 
                        cohends_vars, 
                        Q = cochranQs,
                        mu = mus, 
                        mu_var = mus_vars, 
                        Z = Zs, 
                        Z_pval = Zpvals, 
                        Z_pvalBH = p.adjust(Zpvals, ...))
  
  if(gene_symbol){
    results$Gene <- mapIds(org.Hs.eg.db,
                           keys = row.names(cohends),
                           column = "SYMBOL",
                           keytype = "ENTREZID",
                           multiVals = "first")
  }
  results <- results[order(results$Z_pval),]
  return(results)
}

forest_plot <- function(id, ma_output, title, xlim = NULL){
  #This function will plot the standardized effect size per study and a summary statistic at the bottom. 
  
  #id: gene identifier
  #ma_output: output of the meta-analysis
  #xlim: a vector of two values that represent coordinates for plotting
  
  if(!is.null(xlim) & length(xlim) != 2) stop("xlim must be composed of two values")
  
  id_ma <- ma_output[id,]
  fplot_df <- data.frame(t(id_ma[grep("(d|mu$)", names(id_ma))]),
                         t(id_ma[grep("_var", names(id_ma))]))
  colnames(fplot_df) <- c("cohend", "var")
  rownames(fplot_df)[nrow(fplot_df)] <- "Weighted LSE"
  fplot_df$Name <- rownames(fplot_df)
  fplot_df$Name <- gsub("_d", "", fplot_df$Name)
  fplot_df$Name <- factor(fplot_df$Name, levels = rev(fplot_df$Name))
  fplot_df$Col <- c(rep("black", sum(grepl("_d", rownames(fplot_df)))), "blue")
  
  pobj <- ggplot(fplot_df, aes(x = Name, y = cohend, ymin = cohend-var, ymax = cohend+var, color = Col)) +
    geom_pointrange() +
    geom_hline(yintercept = 0, lty=2) +  # add a dotted line at x=1 after flip
    coord_flip() +  # flip coordinates (puts labels on y axis)
    xlab("") +
    ylab("Effect size") +
    ggtitle(title) +
    scale_color_manual(values=c("#000000", "#0000FF")) +
    theme_bw() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          text = element_text(size=14),
          legend.position = "none")
  
  if(!is.null(xlim)) pobj <- pobj + ylim(xlim)
  
  return(pobj)
}

pairwise_plot <- function(id, contrast, studies_of_interest, exprs_list, title = NULL){
  #This function will plot the input signal for each sample per study colored by the contrast of interest to show the actual difference. 
  
  #id: Entrez gene ID
  #contrast: Macrophage activation state of interest
  #studies_of_interest: The studies to be included in the plot
  #exprs_list: List of expressionSets that are used for plotting
  #title: Title of the plot
  
  expr_interest <- exprs_list[studies_of_interest]
  
  if(is.null(title)){
    title = id
  } 
  
  exprs <- unlist(lapply(expr_interest, function(expr_dat){
    if(class(expr_dat) == "ExpressionSet"){
      ma_samples <- pData(expr_dat)$Group %in% c("M0", contrast)
      expr_dat <- exprs(expr_dat[id, ma_samples])
    } else if(class(expr_dat) == "DGEGLM"){
      rs_samples <- expr_dat$samples$Group %in% c("M0", contrast)
      expr_dat <- cpm(y = expr_dat$counts, log = T)[id, rs_samples]
    }
    
    return(expr_dat)
  }))
  
  pdata <- do.call(rbind, lapply(expr_interest, function(expr_dat){
    if(class(expr_dat) == "ExpressionSet"){
      p_dat <- pData(expr_dat)[pData(expr_dat)$Group %in% c("M0", contrast), c("StudyID", "Group")]
    } else if(class(expr_dat) == "DGEGLM"){
      rs_samples <- expr_dat$samples$Group %in% c("M0", contrast)
      p_dat <- expr_dat$samples[rs_samples, c("StudyID", "Group")]
    }
      
    return(p_dat)
  }))
  
  plot_df <- cbind(pdata, Exprs = exprs)
  colnames(plot_df) <- c("GSE", "Macrophage", "Exprs")
  
  gplot <- ggplot(plot_df, aes(x = Macrophage, y = Exprs)) +
    stat_summary(fun.data = mean_se, geom = "crossbar",  aes(color = Macrophage)) +
    geom_jitter(size = 2, aes(shape = Macrophage)) +
    facet_wrap(~GSE, ncol = 2, scales = "free_y") +
    theme_bw() +
    ggtitle(title) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          axis.text = element_text(size = 17),
          axis.title = element_text(size = 17, face = "bold"),
          axis.title.x = element_blank(),
          legend.title = element_text(size = 17, face = "bold"),
          legend.text = element_text(size = 17),
          legend.position = "none",
          plot.title = element_text(face = "bold"))
  return(gplot)
}
```

##Differential expression

The first step in a meta-analysis would be to calculate the standardized effect sizes in Cohen d. The way we calculate Cohen d is by first performing differential expression analysis and using the obtained statistics to calculate Cohen d.

###Microarray

First we select the microarray studies we will use for the meta-analysis (neither the `Classifier verification`, nor the `In vivo testing` datasets are used at this point in time). Similarly, we will need to select the samples that are relevant for the meta-analysis only.

```{r filter microarray studies and samples of interest for meta-analysis, results = "hide"}
#Studies
ma_microarray_studies <- unique(paste0(samples_microarray$StudyID, "_", samples_microarray$PlatformID)[grep("Meta-analysis", samples_microarray$Cohort)])

norm_microarray_filtered <- norm_microarray_merged[ma_microarray_studies]

#Samples
ma_microarray_samples <- unique(samples_microarray$SampleID[grep("Meta-analysis", samples_microarray$Cohort)])

norm_microarray_filtered <- lapply(norm_microarray_filtered, function(eset, samples){
  eset[, colnames(eset) %in% samples]
}, samples = ma_microarray_samples)
```

For the actual differential expression, we will compare the macrophage activation states against M0, whilst correcting for `Donor`.

```{r microarray differential expression, results = "hide"}
require(limma)

eset_lfit <- function(eset){
  pData(eset)$Group <- as.factor(pData(eset)$Group)
  pData(eset)$Group <- relevel(pData(eset)$Group, "M0")
  pData(eset)$Donor <- as.factor(pData(eset)$Donor)
  
  ifelse(length(levels(pData(eset)$Donor)) == ncol(eset), 
         design_mat <- model.matrix(~ Group, data = pData(eset)),
         design_mat <- model.matrix(~ Group + Donor, data = pData(eset)))
  colnames(design_mat) <- gsub("Group", "", colnames(design_mat))
  
  fit <- lmFit(object = eset, design = design_mat)
  fit <- eBayes(fit)
  return(fit)
}

norm_microarray_fit <- lapply(X = norm_microarray_filtered, FUN = eset_lfit)
```

###RNAseq

```{r filter rnaseq studies of interest for meta-analysis, results = "hide"}
#Studies
ma_rnaseq_studies <- unique(paste0(samples_rnaseq$StudyID)[grep("Meta-analysis", samples_rnaseq$Cohort)])

ma_samples_rnaseq_split <- samples_rnaseq_culled_split[ma_rnaseq_studies]
```

```{r rnaseq design, results = "hide"}
design_splitter <- function(samplesheet){
  samplesheet$Donor <- factor(samplesheet$Donor)
  samplesheet$Group <- factor(samplesheet$Group)
  ifelse(length(levels(samplesheet$Donor)) == nrow(samplesheet),
         design_mat <- model.matrix(~ Group, data = samplesheet),
         design_mat <- model.matrix(~ Donor + Group, data = samplesheet)
         )
  
  colnames(design_mat) <- gsub("^Group(.+)$", "\\1", colnames(design_mat))
  return(design_mat)
}

design_rnaseq_split <- lapply(X = ma_samples_rnaseq_split, FUN = design_splitter)
```

```{r rnaseq differential expression, results = "hide"}
norm_rnaseq_fit <- lapply(X = ma_rnaseq_studies, function(study, dglists, designlists){
  dglist <- estimateDisp(y = dglists[[study]], design = designlists[[study]], robust=TRUE)  
  plotBCV(dglist)
  fit <- glmQLFit(y = dglist, design = designlists[[study]], robust = TRUE, dispersion = dglist$trended.dispersion)  
  plotQLDisp(fit)
  
  return(fit)
}, dglists = rnaseq_dglists, designlists = design_rnaseq_split)

names(norm_rnaseq_fit) <- paste0(ma_rnaseq_studies, "_RNAseq")
```

From the QL display we see that the squeeze was not very strong, suggesting that there is a high degree of variability.

Now that we have all the fits from `limma` and `edgeR`, we can combine them for the meta-analysis.

```{r combine all fits, results = "hide"}
ma_fits <- c(norm_microarray_fit, norm_rnaseq_fit)
ma_samples <- samples[grep("Meta-analysis", samples$Cohort),]
ma_studies_groups <- table(paste0(ma_samples$StudyID, "_", ma_samples$PlatformID), ma_samples$Group)

ma_expression <- c(norm_microarray_filtered, norm_rnaseq_fit)
```

##Meta-regression 

###Calculation

```{r meta-analysis LPSearly vs M0, results = "hide"}
maLPSearlyDir <- file.path(maDir, "LPSearly")
dir.create(maLPSearlyDir)

ma_LPSearly_studies <- names(which(ma_studies_groups[, "MLPSearly"] != 0))
LPSearly_nCTRL <- as.list(ma_studies_groups[ma_LPSearly_studies, "M0"])
LPSearly_nCASE <- as.list(ma_studies_groups[ma_LPSearly_studies, "MLPSearly"])

ma_LPSearly_top <- meta_regressor(fit_list = ma_fits, 
                                  contrast = "MLPSearly", 
                                  studies_of_interest = ma_LPSearly_studies, 
                                  nCTRL_list = LPSearly_nCTRL, 
                                  nCASE_list = LPSearly_nCASE, 
                                  eBayes = T, 
                                  method = "BH")
ma_LPSearly_cdegs <- ma_LPSearly_top[ma_LPSearly_top$Z_pvalBH < 0.05, ]

write.csv(ma_LPSearly_top, file.path(maLPSearlyDir, "LPSearlyvM0.csv"))
#write.csv(ma_LPSearly_top[1:8000,], file.path(maLPSearlyDir, "LPSearlyvM0_top8000.csv"))
write.csv(ma_LPSearly_cdegs, file.path(maLPSearlyDir, "LPSearlyvM0_cDEG.csv"))
```

```{r meta-analysis LPSlate vs M0, results = "hide"}
maLPSlateDir <- file.path(maDir, "LPSlate")
dir.create(maLPSlateDir)

ma_LPSlate_studies <- names(which(ma_studies_groups[, "MLPSlate"] != 0))
LPSlate_nCTRL <- as.list(ma_studies_groups[ma_LPSlate_studies, "M0"])
LPSlate_nCASE <- as.list(ma_studies_groups[ma_LPSlate_studies, "MLPSlate"])

ma_LPSlate_top <- meta_regressor(fit_list = ma_fits, 
                                 contrast = "MLPSlate", 
                                 studies_of_interest = ma_LPSlate_studies, 
                                 nCTRL_list = LPSlate_nCTRL, 
                                 nCASE_list = LPSlate_nCASE, 
                                 eBayes = T, 
                                 method = "BH")
ma_LPSlate_cdegs <- ma_LPSlate_top[ma_LPSlate_top$Z_pvalBH < 0.05, ]

write.csv(ma_LPSlate_top, file.path(maLPSlateDir, "LPSlatevM0.csv"))
#write.csv(ma_LPSlate_top[1:8000,], file.path(maLPSlateDir, "LPSlatevM0_top8000.csv"))
write.csv(ma_LPSlate_cdegs, file.path(maLPSlateDir, "LPSlatevM0_cDEG.csv"))
```

```{r meta-analysis LPSIFNg vs M0, results = "hide"}
maLPSIFNgDir <- file.path(maDir, "LPSIFNg")
dir.create(maLPSIFNgDir)

ma_LPSIFNg_studies <- names(which(ma_studies_groups[, "MLPSIFNg"] != 0))
LPSIFNg_nCTRL <- as.list(ma_studies_groups[ma_LPSIFNg_studies, "M0"])
LPSIFNg_nCASE <- as.list(ma_studies_groups[ma_LPSIFNg_studies, "MLPSIFNg"])

ma_LPSIFNg_top <- meta_regressor(fit_list = ma_fits, 
                                 contrast = "MLPSIFNg", 
                                 studies_of_interest = ma_LPSIFNg_studies, 
                                 nCTRL_list = LPSIFNg_nCTRL, 
                                 nCASE_list = LPSIFNg_nCASE, 
                                 eBayes = T, 
                                 method = "BH")
ma_LPSIFNg_cdegs <- ma_LPSIFNg_top[ma_LPSIFNg_top$Z_pvalBH < 0.05, ]

write.csv(ma_LPSIFNg_top, file.path(maLPSIFNgDir, "LPSIFNgvM0.csv"))
#write.csv(ma_LPSIFNg_top[1:8000,], file.path(maLPSIFNgDir, "LPSIFNgvM0_top8000.csv"))
write.csv(ma_LPSIFNg_cdegs, file.path(maLPSIFNgDir, "LPSIFNgvM0_cDEG.csv"))
```

```{r meta-analysis IFNg vs M0, results = "hide"}
maIFNgDir <- file.path(maDir, "IFNg")
dir.create(maIFNgDir)

ma_IFNg_studies <- names(which(ma_studies_groups[, "MIFNg"] != 0))
IFNg_nCTRL <- as.list(ma_studies_groups[ma_IFNg_studies, "M0"])
IFNg_nCASE <- as.list(ma_studies_groups[ma_IFNg_studies, "MIFNg"])

ma_IFNg_top <- meta_regressor(fit_list = ma_fits, 
                              contrast = "MIFNg", 
                              studies_of_interest = ma_IFNg_studies, 
                              nCTRL_list = IFNg_nCTRL, 
                              nCASE_list = IFNg_nCASE, 
                              eBayes = T, 
                              method = "BH")
ma_IFNg_cdegs <- ma_IFNg_top[ma_IFNg_top$Z_pvalBH < 0.05, ]

write.csv(ma_IFNg_top, file.path(maIFNgDir, "IFNgvM0.csv"))
#write.csv(ma_IFNg_top[1:8000,], file.path(maIFNgDir, "IFNgvM0_top8000.csv"))
write.csv(ma_IFNg_cdegs, file.path(maIFNgDir, "IFNgvM0_cDEG.csv"))
```

```{r meta-analysis IL4 vs M0, results = "hide"}
maIL4Dir <- file.path(maDir, "IL4")
dir.create(maIL4Dir)

ma_IL4_studies <- names(which(ma_studies_groups[, "MIL4"] != 0))
IL4_nCTRL <- as.list(ma_studies_groups[ma_IL4_studies, "M0"])
IL4_nCASE <- as.list(ma_studies_groups[ma_IL4_studies, "MIL4"])

ma_IL4_top <- meta_regressor(fit_list = ma_fits, 
                             contrast = "MIL4", 
                             studies_of_interest = ma_IL4_studies, 
                             nCTRL_list = IL4_nCTRL, 
                             nCASE_list = IL4_nCASE, 
                             eBayes = T, 
                             method = "BH")
ma_IL4_cdegs <- ma_IL4_top[ma_IL4_top$Z_pvalBH < 0.05, ]

write.csv(ma_IL4_top, file.path(maIL4Dir, "IL4vM0.csv"))
#write.csv(ma_IL4_top[1:8000,], file.path(maIL4Dir, "IL4vM0_top8000.csv"))
write.csv(ma_IL4_cdegs, file.path(maIL4Dir, "IL4vM0_cDEG.csv"))
```

```{r meta-analysis IL10 vs M0, results = "hide"}
maIL10Dir <- file.path(maDir, "IL10")
dir.create(maIL10Dir)

ma_IL10_studies <- names(which(ma_studies_groups[, "MIL10"] != 0))
IL10_nCTRL <- as.list(ma_studies_groups[ma_IL10_studies, "M0"])
IL10_nCASE <- as.list(ma_studies_groups[ma_IL10_studies, "MIL10"])

ma_IL10_top <- meta_regressor(fit_list = ma_fits, 
                              contrast = "MIL10", 
                              studies_of_interest = ma_IL10_studies, 
                              nCTRL_list = IL10_nCTRL, 
                              nCASE_list = IL10_nCASE, 
                              eBayes = T, 
                              method = "BH")
ma_IL10_cdegs <- ma_IL10_top[ma_IL10_top$Z_pvalBH < 0.05, ]

write.csv(ma_IL10_top, file.path(maIL10Dir, "IL10vM0.csv"))
#write.csv(ma_IL10_top[1:8000,], file.path(maIL10Dir, "IL10vM0_top8000.csv"))
write.csv(ma_IL10_cdegs, file.path(maIL10Dir, "IL10vM0_cDEG.csv"))
```

```{r meta-analysis dex vs M0, results = "hide"}
madexDir <- file.path(maDir, "dex")
dir.create(madexDir)

ma_dex_studies <- names(which(ma_studies_groups[, "Mdex"] != 0))
dex_nCTRL <- as.list(ma_studies_groups[ma_dex_studies, "M0"])
dex_nCASE <- as.list(ma_studies_groups[ma_dex_studies, "Mdex"])

ma_dex_top <- meta_regressor(fit_list = ma_fits, 
                             contrast = "Mdex", 
                             studies_of_interest = ma_dex_studies, 
                             nCTRL_list = dex_nCTRL, 
                             nCASE_list = dex_nCASE, 
                             eBayes = T, 
                             method = "BH")
ma_dex_cdegs <- ma_dex_top[ma_dex_top$Z_pvalBH < 0.05, ]

write.csv(ma_dex_top, file.path(madexDir, "dexvM0.csv"))
#write.csv(ma_dex_top[1:8000,], file.path(madexDir, "dexvM0_top8000.csv"))
write.csv(ma_dex_cdegs, file.path(madexDir, "dexvM0_cDEG.csv"))
```

###Summary visualization

Having done all the calculations, it becomes time to visualize what we have actually found. First we would want to visualize the overall meta-analysis results by plotting the *p*-value relative to the effect size.

```{r meta-analysis volcano_plot, fig.width = 10, fig.height = 7.5, fig.align = "center"}
#Cairo(file = file.path(maLPSearlyDir, "LPSearly_volcano.png"), type = "png", units = "px", width = 800, height = 800, dpi = 90, bg = "white")
ggarrange(LPSearly = volcano_plot(effect_sizes = ma_LPSearly_top$mu, 
                                  pvals = ma_LPSearly_top$Z_pval, 
                                  significance = ma_LPSearly_top$Z_pvalBH < 0.05, 
                                  identifiers = ma_LPSearly_top$Gene, 
                                  int_effect_threshold = 0.8, 
                                  p_limit = 12.5,
                                  top_names = 10,
                                  title = "MLPSearly vs M0"),
          LPSlate = volcano_plot(effect_sizes = ma_LPSlate_top$mu, 
                                 pvals = ma_LPSlate_top$Z_pval, 
                                 significance = ma_LPSlate_top$Z_pvalBH < 0.05, 
                                 identifiers = ma_LPSlate_top$Gene, 
                                 int_effect_threshold = 0.8, 
                                 p_limit = 12.5,
                                 top_names = 10,
                                 title = "MLPSlate vs M0"),
          LPSIFNg = volcano_plot(effect_sizes = ma_LPSIFNg_top$mu, 
                                 pvals = ma_LPSIFNg_top$Z_pval, 
                                 significance = ma_LPSIFNg_top$Z_pvalBH < 0.05, 
                                 identifiers = ma_LPSIFNg_top$Gene, 
                                 int_effect_threshold = 0.8, 
                                 p_limit = 12.5,
                                 top_names = 10,
                                 title = "MLPSIFNg vs M0"),
          IFNg = volcano_plot(effect_sizes = ma_IFNg_top$mu, 
                              pvals = ma_IFNg_top$Z_pval, 
                              significance = ma_IFNg_top$Z_pvalBH < 0.05, 
                              identifiers = ma_IFNg_top$Gene, 
                              int_effect_threshold = 0.8, 
                              p_limit = 12.5,
                              top_names = 10,
                              title = "MIFNg vs M0"),
          IL4 = volcano_plot(effect_sizes = ma_IL4_top$mu, 
                             pvals = ma_IL4_top$Z_pval, 
                             significance = ma_IL4_top$Z_pvalBH < 0.05, 
                             identifiers = ma_IL4_top$Gene, 
                             int_effect_threshold = 0.8, 
                             p_limit = 12.5,
                             top_names = 10,
                             title = "MIL4 vs M0"),
          IL10 = volcano_plot(effect_sizes = ma_IL10_top$mu, 
                              pvals = ma_IL10_top$Z_pval, 
                              significance = ma_IL10_top$Z_pvalBH < 0.05, 
                              identifiers = ma_IL10_top$Gene, 
                              int_effect_threshold = 0.8, 
                              p_limit = 12.5,
                              top_names = 10,
                              title = "MIL10 vs M0"),
          dex = volcano_plot(effect_sizes = ma_dex_top$mu, 
                             pvals = ma_dex_top$Z_pval, 
                             significance = ma_dex_top$Z_pvalBH < 0.05, 
                             identifiers = ma_dex_top$Gene, 
                             int_effect_threshold = 0.8, 
                             p_limit = 12.5,
                             top_names = 10,
                             title = "Mdex vs M0"),
          nrow = 2,
          ncol = 4)
#dev.off()
```

We previously observed substantial differences between certain macrophage activation states and M0. A different way of visualizing this is by means of principal component analysis. To this end, we must first reduce the genes that were found to overlap among all comparisons.

```{r cohend summarizing, results = "hide"}
ma_overlapping_genes_entrez <- Reduce(intersect, lapply(ma_fits, rownames))
ma_overlapping_genes_hgnc <- mapIds(org.Hs.eg.db,
                                    keys = ma_overlapping_genes_entrez,
                                    column = "SYMBOL",
                                    keytype = "ENTREZID",
                                    multiVals = "first")

ma_cohend <- data.frame(
  MLPSearly = ma_LPSearly_top[ma_overlapping_genes_entrez, grep("_d", colnames(ma_LPSearly_top))],
  MLPSlate = ma_LPSlate_top[ma_overlapping_genes_entrez, grep("_d", colnames(ma_LPSlate_top))],
  MLPSIFNg = ma_LPSIFNg_top[ma_overlapping_genes_entrez, grep("_d", colnames(ma_LPSIFNg_top))],
  MIFNg = ma_IFNg_top[ma_overlapping_genes_entrez, grep("_d", colnames(ma_IFNg_top))],
  MIL4 = ma_IL4_top[ma_overlapping_genes_entrez, grep("_d", colnames(ma_IL4_top))],
  MIL10 = ma_IL10_top[ma_overlapping_genes_entrez, grep("_d", colnames(ma_IL10_top))],
  Mdex = ma_dex_top[ma_overlapping_genes_entrez, grep("_d", colnames(ma_dex_top))])
```

One way of visualizing the different Cohen d is by using principal component analysis (PCA). 

```{r cohend pca, fig.width = 7.5, fig.height = 7.5, fig.align = "center"}
ma_cohend_svd <- svd(sweep(x = t(ma_cohend), MARGIN = 2, STATS = colMeans(t(ma_cohend)), FUN = "-"))

ma_cohend_svd_plot_df <- data.frame(PC1 = ma_cohend_svd$u[,1],
                                    PC2 = ma_cohend_svd$u[,2],
                                    Macrophage = gsub("(M.+?)\\..+?_.+?_d", "\\1", colnames(ma_cohend)),
                                    Study = gsub("M.+?\\.(.+?)_.+?_d", "\\1", colnames(ma_cohend)),
                                    Experiment = grepl("RNAseq", colnames(ma_cohend)))
ma_cohend_svd_plot_df$Experiment[which(ma_cohend_svd_plot_df$Experiment)] <- "RNAseq" 
ma_cohend_svd_plot_df$Experiment[which(ma_cohend_svd_plot_df$Experiment == "FALSE")] <- "Microarray" 

#Cairo(file = file.path(edaDir, "cohend_pca.pdf"), type = "pdf", units = "px", width = 800, height = 800, dpi = 90, bg = "white")
ggplot(ma_cohend_svd_plot_df, aes(x = PC1, y = PC2, color = Macrophage, shape = Experiment)) + 
  geom_point(size = 4) +
  theme_bw() +
  ggtitle("PC1 vs PC2") +
  ylab("PC2") +
  xlab("PC1") +
  geom_vline(xintercept = 0.065, col = "darkgrey", linetype = "dashed") +
  scale_color_manual(values = Mcolors[-1]) +
  theme(axis.text = element_text(size = 12), 
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        legend.position = "bottom")
# dev.off()
```

We see a large spread, which appears to be caused by a couple of samples. Despite such outliers, we appear to see (with some imagination), that the MLPSearly, MLPSlate, and MLPSIFNg are located on the left side, whereas the MIL4, MIL10, and Mdex are located on the right side, with the separation occuring at around 0.06 on PC1. This separation broadly corresponds to the M1 and M2 paradigm with MLPSearly, MLPSlate, and MLPSIFNg being called M1 and MIL4, MIL10, and Mdex being M2. Interestingly, despite the fact that each sample represents a study-macrophage pair, most M2 macrophages appear to cluster according to macrophages rather than by studies. 

```{r ranked cohend pca, fig.width = 7.5, fig.height = 7.5, fig.align = "center"}
ma_cohend_ranked <- apply(ma_cohend, 2, rank)

ma_cohend_ranked_svd <- svd(sweep(x = t(ma_cohend_ranked), MARGIN = 2, STATS = colMeans(t(ma_cohend_ranked)), FUN = "-"))

ma_cohend_ranked_svd_plot_df <- data.frame(PC1 = ma_cohend_ranked_svd$u[,1],
                                    PC2 = ma_cohend_ranked_svd$u[,2],
                                    Macrophage = gsub("(M.+?)\\..+?_.+?_d", "\\1", colnames(ma_cohend)),
                                    Study = gsub("M.+?\\.(.+?)_.+?_d", "\\1", colnames(ma_cohend)),
                                    Experiment = grepl("RNAseq", colnames(ma_cohend)))
ma_cohend_ranked_svd_plot_df$Experiment[which(ma_cohend_ranked_svd_plot_df$Experiment)] <- "RNAseq" 
ma_cohend_ranked_svd_plot_df$Experiment[which(ma_cohend_ranked_svd_plot_df$Experiment == "FALSE")] <- "Microarray" 

#Cairo(file = file.path(edaDir, "cohend_pca.pdf"), type = "pdf", units = "px", width = 800, height = 800, dpi = 90, bg = "white")
ggplot(ma_cohend_ranked_svd_plot_df, aes(x = PC1, y = PC2, color = Macrophage, shape = Experiment)) + 
  geom_point(size = 4) +
  theme_bw() +
  ggtitle("PC1 vs PC2") +
  ylab("PC2") +
  xlab("PC1") +
  scale_color_manual(values = Mcolors[-1]) +
  theme(axis.text = element_text(size = 12), 
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        legend.position = "bottom")
# dev.off()
```

Another way of visualizing the similarity between samples is by looking at the correlation structure. Essentially, this will not yield very different from PCA as the correlation coefficient calculated is simply the standardized (co)variance. Note that we will use the Spearman correlation, as we learned previously that unranked metrics will be overshadowed by the effect of a few outlier samples.

```{r cohend correlation, fig.width = 7.5, fig.height = 7.5, fig.align = "center"}
require(pheatmap)

ma_cohend_cor <- cor(ma_cohend, method = "spearman")
ma_cohend_sample_anno <- data.frame(Macrophage = gsub("(M.+?)\\..+?_.+?_d", "\\1", colnames(ma_cohend)),
                                    Study = gsub("M.+?\\.(.+?)_.+?_d", "\\1", colnames(ma_cohend)), 
                                    #Platform = gsub("M.+?\\..+?_(.+)?_d", "\\1", colnames(ma_cohend)),
                                    row.names = colnames(ma_cohend))
ma_cohend_sample_colors <- data.frame(color = Mcolors[ma_cohend_sample_anno$Macrophage], 
                                      row.names = colnames(ma_cohend_cor))

#Cairo(file = file.path(edaDir, "cohend_correlations.pdf"), type = "pdf", units = "px", width = 800, height = 800, dpi = 90, bg = "white")
pheatmap(ma_cohend_cor, 
         annotation_col = ma_cohend_sample_anno, 
         annotation_row = ma_cohend_sample_anno, 
         show_rownames = F, 
         show_colnames = F,
         annotation_colors = list(Macrophage = Mcolors[-1])
         )
#dev.off()

write.csv(ma_cohend_cor, file.path(edaDir, "cohend_correlations.csv"))
```

A more concise way of visualizing the PCA is by performing it on the Z-values calculated from the standardized effect sizes. 

```{r cohend zvalue pca, fig.width = 7.5, fig.height = 7.5, fig.align = "center"}
ma_Z <- data.frame(
  MLPSearly = ma_LPSearly_top[ma_overlapping_genes_entrez, "Z"],
  MLPSlate = ma_LPSlate_top[ma_overlapping_genes_entrez, "Z"],
  MLPSIFNg = ma_LPSIFNg_top[ma_overlapping_genes_entrez, "Z"],
  MIFNg = ma_IFNg_top[ma_overlapping_genes_entrez, "Z"],
  MIL4 = ma_IL4_top[ma_overlapping_genes_entrez, "Z"],
  MIL10 = ma_IL10_top[ma_overlapping_genes_entrez, "Z"],
  Mdex = ma_dex_top[ma_overlapping_genes_entrez, "Z"])

ma_Z_svd <- svd(sweep(x = t(ma_Z), MARGIN = 2, STATS = colMeans(t(ma_Z)), FUN = "-"))
ma_Z_svd_varexp <- ma_Z_svd$d/sum(ma_Z_svd$d)
names(ma_Z_svd_varexp) <- paste0("PC", 1:length(ma_Z_svd_varexp))

ma_Z_svd_plot_df <- data.frame(PC1 = ma_Z_svd$u[,1],
                               PC2 = ma_Z_svd$u[,2],
                               Macrophage = factor(colnames(ma_Z), levels = colnames(ma_Z)),
                               Colors = as.character(Mcolors[colnames(ma_Z)]))

#Cairo(file = file.path(edaDir, "z_pca.pdf"), type = "pdf", units = "px", width = 800, height = 800, dpi = 90, bg = "white")
ggplot(ma_Z_svd_plot_df, aes(x = PC1, y = PC2, color = Macrophage)) + 
  geom_point(size = 4) +
  theme_bw() +
  ggtitle("PC1 vs PC2") +
  ylab(paste0("PC2 (", round(ma_Z_svd_varexp["PC2"]*100, 1), "%)")) +
  xlab(paste0("PC1 (", round(ma_Z_svd_varexp["PC1"]*100, 1), "%)")) +
  scale_color_manual(values=as.character(ma_Z_svd_plot_df$Colors)) +
  theme(axis.text = element_text(size = 12), 
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        legend.position = "bottom")
#dev.off()
```

###Genewise visualization

Having visualized the result of the meta-analysis, the question is whether visually we can see this consistent difference. 

```{r standardized effect size genewise visualization}
ggarrange(forest_plot(id = "3575", ma_output = ma_LPSearly_cdegs, title = "MLPSearly vs M0: IL7R"),
          forest_plot(id = "3553", ma_output = ma_LPSlate_cdegs, title = "MLPSlate vs M0: IL1B"),
          forest_plot(id = "4856", ma_output = ma_LPSlate_cdegs, title = "MLPSlate vs M0: NOV"),
          forest_plot(id = "136", ma_output = ma_LPSIFNg_cdegs, title = "MLPS+IFNg vs M0: ADORA2B"),
          forest_plot(id = "4856", ma_output = ma_IFNg_cdegs, title = "MIFNg vs M0: NOV"),
          forest_plot(id = "6361", ma_output = ma_IL4_cdegs, title = "MIL4 vs M0: CCL17"),
          forest_plot(id = "283316", ma_output = ma_IL10_cdegs, title = "MIL10 vs M0: CD163L1"),
          forest_plot(id = "9332", ma_output = ma_dex_cdegs, title = "Mdex vs M0: CD163"),
          nrow = 2, ncol = 4)
```

While the standardized effect size is a good indication of whether an effect is consistent, it is an extra layer of abstraction introduced from the "raw" expression values. It is therefore useful to also visualize the cDEGs within that context.

```{r raw meta-analysis genewise visualization, fig.width = 8, fig.height = 10, fig.align = "center"}
ggarrange(pairwise_plot(id = rownames(ma_LPSearly_top)[1], 
                        contrast = "MLPSearly", 
                        studies = ma_LPSearly_studies, 
                        exprs_list = ma_expression, 
                        title = paste0("MLPSearly vs M0: ", ma_LPSearly_top[1,]$Gene)),
          pairwise_plot(id = rownames(ma_LPSlate_top)[1], 
                        contrast = "MLPSlate", 
                        studies = ma_LPSlate_studies, 
                        exprs_list = ma_expression, 
                        title = paste0("MLPSlate vs M0: ", ma_LPSlate_top[1,]$Gene)),
          pairwise_plot(id = rownames(ma_LPSIFNg_top)[1], 
                        contrast = "MLPSIFNg", 
                        studies = ma_LPSIFNg_studies, 
                        exprs_list = ma_expression, 
                        title = paste0("MLPSIFNg vs M0: ", ma_LPSIFNg_top[1,]$Gene)),
          pairwise_plot(id = rownames(ma_IFNg_top)[1], 
                        contrast = "MIFNg", 
                        studies = ma_IFNg_studies, 
                        exprs_list = ma_expression, 
                        title = paste0("MIFNg vs M0: ", ma_IFNg_top[1,]$Gene)),
          pairwise_plot(id = rownames(ma_IL4_top)[1], 
                        contrast = "MIL4", 
                        studies = ma_IL4_studies, 
                        exprs_list = ma_expression, 
                        title = paste0("MIL4 vs M0: ", ma_IL4_top[1,]$Gene)),
          pairwise_plot(id = rownames(ma_IL10_top)[1], 
                        contrast = "MIL10", 
                        studies = ma_IL10_studies, 
                        exprs_list = ma_expression, 
                        title = paste0("MIL10 vs M0: ", ma_IL10_top[1,]$Gene)),
          pairwise_plot(id = rownames(ma_dex_top)[1], 
                        contrast = "Mdex", 
                        studies = ma_dex_studies, 
                        exprs_list = ma_expression, 
                        title = paste0("Mdex0 vs M0: ", ma_dex_top[1,]$Gene)),
          nrow = 2, ncol = 4)
```

With this, we have completed the meta-analysis on the macrophage activation states versus M0. 

#Elastic net classification

We are now going to perform a classification analysis to see whether we can distinguish one macrophage subset from the rest. In particular, we sought to answer the question whether we could 1) properly distinguish different macrophage subsets, and 2) extract the features (genes) that were responsible for the classification (feature selection). To this end, we utilized a penalized regression approach as these methods are based on linear regression approaches, but specifically also perform feature selection. 
For validation purposes, the data will be split into two parts, the training (2/3) and the test set (1/3). As such a split must be clean (i.e. information from one set should not leak into the other) we implemented two additional measures to prevent biases: 1) we will utilize the non-normalized data as normalizations such as quantile normalizations borrow information from samples within the same studies, and 2) our own RNAseq experiment will be incorporated in the test set in its entirety to properly validate the model on samples not seen before.
Training the model will be done using a 10-fold cross-validation approach where the training data is further split into 10 equal chunks and the model is trained on 9 and validated on the remainder chunk. Unfortunately, simply splitting the training data a single time could yield an unlucky split. To this end, we implemented a repeated cross-validation approach to stabilize the coefficients (log odds ratios) and the predictions. Examples as to why this yields more robust predictions can be found [here](https://www.kaggle.com/sinanhersek/why-use-repeated-cross-validation) and [here](https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2010.00740.x). Implementation-wise this simply amounts to adding an outer-loop that repeats the cross-validation approach `B` times.

##Classifier setup

```{r classifier samples, results = "hide"}
cl_samples <- samples[grep("Classifier building", samples$Cohort),]

#Remove bad samples
cl_samples <- cl_samples[!cl_samples$SampleID %in% bad_rnaseq_samples,]

cl_studies <- unique(cl_samples$StudyID)
cl_studies_platform <- unique(paste0(cl_samples$StudyID, "_", cl_samples$PlatformID))
```

We will only perform classification on genes that are present in all training datasets. Moreover, genes located on chromosome Y will be removed. Why do we not remove all the allosomes? Some of the known macrophage predictor genes are located on chromosome X.

```{r classifier genes search space, results = "hide"}
cl_microarray_genes <- Reduce(intersect, lapply(nonnorm_microarray_merged[names(nonnorm_microarray_merged) %in% cl_studies_platform], rownames))
cl_rnaseq_genes <- Reduce(intersect, lapply(rnaseq_dglists[names(rnaseq_dglists) %in% cl_studies], rownames))

cl_genes <- intersect(cl_microarray_genes, cl_rnaseq_genes)

#Entrez to hgnc symbol to chromosome
entrez2symbol <- getBM(attributes = c("entrezgene", "hgnc_symbol", "chromosome_name"), filters = "entrezgene", values = cl_genes, mart = ensembl)

cl_genes_nonY <- as.character(unique(entrez2symbol$entrezgene[entrez2symbol$chromosome_name != "Y"]))
```

```{r classification object setup, results = "hide"}
cl_microarray_exprs <- lapply(nonnorm_microarray_merged[names(nonnorm_microarray_merged) %in% cl_studies_platform], function(eset){
  exprs(eset)[cl_genes_nonY, colnames(eset) %in% cl_samples$SampleID]
})

cl_rnaseq_counts <- lapply(rnaseq_dglists, function(dglist){
  counts <- cpm(dglist$counts, log = T, prior.count = 1, normalized.lib.sizes = F)
  counts[cl_genes_nonY,]
})

cl_expression <- c(cl_microarray_exprs, cl_rnaseq_counts)
```

We can visualize our input data using a histogram. 

```{r classification expression values distribution visualization, fig.width = 7.5, fig.height = 7.5}
histoplotter <- function(exprs_list){
  #This function will take a list of expression values and plot a histogram for each.
  
  #exprs_list: A list of expression values
  
  ceil_studies <- ceiling(sqrt(length(exprs_list)))
  
  par(mfrow = c(ceil_studies, ceil_studies))
  for(i in 1:length(exprs_list)){
    hist(exprs_list[[i]], 
         xlim = c(-10, 20), 
         xlab = "Exprs",
         main = names(exprs_list[i]))
  }
}

histoplotter(cl_expression)
```

We observe that the microarray datasets generally display a normal distribution. Note that the distribution of `MEXP2032` is different. The RNAseq datasets also display a reasonably normal distribution, although their left tails dip more into the negative values. Nonetheless, we are curious how well the classifier will train on the data in its "purest" format. 

```{r classification dataframe creation, results = "hide"}
cl_expression_df <- do.call(cbind, cl_expression)
#Sort the data frame to match the samplesheet
cl_expression_df <- cl_expression_df[,cl_samples$SampleID]
```

Given the observed differences in distribution, we were curious how the overall PCA would look like. Based on the previous distribution, we hazard a guess that the study-specific effects will be very large.

```{r classification expression values PCA, fig.width = 7.5, fig.height = 7.5}
pcaplotter <- function(exprs_df, pdata_df){
  #This function will take a matrix expression values and plot a histogram for each.
  
  #exprs_df: A dataframe of expression data
  #pdata_df: A dataframe of phenodata associated to the expression data
  
  exprs_demeaned <- exprs_df-rowMeans(exprs_df)
  
  exprs_svd <- svd(t(exprs_demeaned))
  exprs_svd_df <- data.frame(Study = pdata_df$StudyID,
                             Platform = pdata_df$Platform,
                             Group = pdata_df$Group, 
                             PC1 = exprs_svd$u[, 1], 
                             PC2 = exprs_svd$u[, 2],
                             Feature = "Raw")
  
  exprs_svd_plot <- ggplot(exprs_svd_df, aes(x = PC1, y = PC2, col = Study, shape = Group, Label = Platform)) +
    scale_shape_manual(values = (1:nlevels(exprs_svd_df$Group))%%10) +
    geom_point() +
    theme_bw()
  
  print(exprs_svd_plot)
}

pcaplotter(cl_expression_df, cl_samples)
```

As expected, the most visible determining factor that drives clustering appears to be the study. 

```{r classification functions, results = "hide"}
testsamples_function <- function(studydata, groups, test_study, ntest, iseed = NULL){
  #This function will yield indexes for samples to be divided into the training and the test set to ensure that each group is equally represented.
  
  #studydata: Vector of study IDs of length equal to the total number of the entire trainingset.
  #groups: Vector of the group IDs of length equal to the total number of the entire trainingset.
  #test_study: Name of the study that is to be in the test set.
  #ntest: A named vector with the number of test samples per set.
  #iseed: The seed for reproducibility purposes.
  
  if(is.null(studydata)) stop("No 'studydata' provided")
  if(is.null(groups)) stop("No 'groups' provided")
  if(!is.null(iseed)) set.seed(iseed)
  if(!test_study %in% studydata) stop("'test_study' does not exist in studydata")

  total_data <- data.frame(index = 1:length(groups), groups, studydata)
  
  #Find indexes associated to the study to be in the test set
  test_index <- total_data$index[(studydata == test_study)]
  ntest_primary <- table(groups[test_index])
  
  #Subtract the indexes from the initial index
  ntest_remainder <- foreach(i = 1:length(ntest_primary), .combine = c) %do% {
    comparison_name <- names(ntest_primary)[i]
    ntest[comparison_name] - ntest_primary[comparison_name]
  }
  
  #Subtract the indexes from the provided samples
  data_remainder <- total_data[-test_index,]
  
  #Use the remainder data in the sampler
  testset <- foreach(i = 1:length(ntest_remainder), .combine = c) %do% {
    sample(x = data_remainder$index[which(data_remainder$groups == names(ntest_remainder)[i])], 
           size = ntest_remainder[i], 
           replace = F)
  }
  
  testset <- c(test_index, testset)
  
  return(testset)
}
```

For the classification approach we will divide the data into a training set (2/3) and a test set (1/3).

```{r training and test size, results = "hide"}
ntest_size <- ceiling(table(cl_samples$Group)/3)
ntrain_size <- table(cl_samples$Group)-ntest_size
```

We next need to randomly select samples for in the test and the training set. During this step, we must ensure that each macrophage subset is divided into 2/3 and 1/3 lest we bias the training of the classification.

```{r creating the test set, results = "hide"}
test_indexes <- testsamples_function(studydata = cl_samples$Study, 
                                     groups = cl_samples$Group, 
                                     test_study = "exp068", 
                                     ntest = ntest_size, 
                                     iseed = 17459)
                                          
#samples
test_cl_samples <- cl_samples[test_indexes,]
training_cl_samples <- cl_samples[-test_indexes,]

#expression data
test_cl_expression <- cl_expression_df[,test_indexes]
training_cl_expression <- cl_expression_df[,-test_indexes]
```

Important note! Due to my infinite wisdom while cleaning up the samplesheet, the randomly chosen indexes assigned to the "old" test set do not correspond to the "new" test set. In other words, exact reproducibility is not possible. For the creation of the model this does not matter (that is the whole point of stabilization). However, stabilization does not mean the exact same features with the exact same coefficients will be retrieved. As some of the downstream chunks discuss some specific samples, I will replace the training and test set as described above with the ones I have used previously. I implore you however to have a look what happens if you try out the random resampling to see what result you get in the end.

```{r test and training manuscript data}
data("testset_metadata")

#Training and test set as reported in the manuscript
test_cl_samples <- cl_samples[cl_samples$SampleID %in% testset_metadata$Sample,]
training_cl_samples <- cl_samples[!cl_samples$SampleID %in% testset_metadata$Sample,]
test_cl_expression <- cl_expression_df[,test_cl_samples$SampleID]
training_cl_expression <- cl_expression_df[,training_cl_samples$SampleID]
```

```{r check test and training set}
table(test_cl_samples$Group)
table(training_cl_samples$Group)
table(test_cl_samples$Group) + table(training_cl_samples$Group) == table(cl_samples$Group)

intersect(test_cl_samples$SampleID, training_cl_samples$SampleID)
```

We observe that each macrophage subset has indeed been subdivided into 1/3 for the test and 2/3 for the training set and that none of the test data has been included in the training data. As a final check that all the data looks reasonably similar, we plot the distribution of the training and the test.

```{r training and test set distribution, fig.width = 7.5, fig.height = 7.5}
training_cl_expression_melt <- melt(training_cl_expression, value.name = "expr", varnames = c("entrez", "sample"))
test_cl_expression_melt <- melt(test_cl_expression, value.name = "expr", varnames = c("entrez", "sample"))

cl_expression_hist_df <- rbind(data.frame(training_cl_expression_melt, group = "Training"), 
                               data.frame(test_cl_expression_melt, group = "Test"))

#Histogram
# ggplot(cl_expression_hist_df, aes(x = expr, color = group, fill = group)) +
#   geom_histogram(bins = 100, alpha = 0.6) +
#   #geom_density() +
#   xlab("Expression") +
#   ylab("Frequency") +
#   theme_bw() +
#   theme(text = element_text(size=16),
#         legend.position="bottom")

#Density plot
ggplot(cl_expression_hist_df, aes(x = expr, color = group)) +
  geom_density() +
  xlab("Expression") +
  ylab("Frequency") +
  theme_bw() +
  theme(text = element_text(size=16),
        legend.position="bottom")
```

We observe a reasonably similar distribution as expected.

##Classifier training

Having prepared the data for classification, we can now implement the repeated cross-validation approach for elastic net regression. For elastic net regression we will use the `glmnet` function as implemented in the `glmnet` package. We will subsequently also wrap it up in a 

```{r classification elastic net}
require(glmnet)
require(doParallel)

rep_cv <- function(x, y, B, alpha, standardize = F, weights = NULL){
  #A wrapper function that performs repeated cross-validation using cv.glmnet estimates. As such, most of the provided arguments are immediately fed into the cv.glmnet function. 
  
  #x: Training expression data where samples are in the rows and genes in the columns.
  #y: Training labels.
  #B: Number of repetitions to perform.
  #alpha: A hyperparameter fed to cv.glmnet that determines how much lasso (1) or ridge (0) the classification model is. 
  
  if(is.null(weights)) weights <- rep(1, length(y))
  
  lambda_df <- M0_df <- MLPSearly_df <- MLPSlate_df <- MLPSIFNg_df <- MIFNg_df <- MIL4_df <- MIL10_df <- Mdex_df <- c()
  
  cv_it <- foreach(i = 1:B, .export = 'cv.glmnet.norm', .packages = 'glmnet') %dopar% {
    classifier <- cv.glmnet(x = x, 
                            y = y, 
                            alpha = alpha, 
                            family = "multinomial", 
                            standardize = standardize,
                            weights = weights)
    glmnet_cv_coef <- coef(classifier, s = "lambda.min")
    coef_M0 <- as.matrix(glmnet_cv_coef$M0)
    coef_MLPSearly <- as.matrix(glmnet_cv_coef$MLPSearly)
    coef_MLPSlate <- as.matrix(glmnet_cv_coef$MLPSlate)
    coef_MLPSIFNg <- as.matrix(glmnet_cv_coef$MLPSIFNg)
    coef_MIFNg <- as.matrix(glmnet_cv_coef$MIFNg)
    coef_MIL4 <- as.matrix(glmnet_cv_coef$MIL4)
    coef_MIL10 <- as.matrix(glmnet_cv_coef$MIL10)
    coef_Mdex <- as.matrix(glmnet_cv_coef$Mdex)
    
    return(list(lambda = classifier$lambda.min, 
                M0 = coef_M0[,], 
                MLPSearly = coef_MLPSearly[,], 
                MLPSlate = coef_MLPSlate[,], 
                MLPSIFNg = coef_MLPSIFNg[,], 
                MIFNg = coef_MIFNg[,],
                MIL4 = coef_MIL4[,],
                MIL10 = coef_MIL10[,],
                Mdex = coef_Mdex[,]))
  }
  
  lambda_df <- unlist(lapply(cv_it, function(i) i$lambda))
  M0_df <- do.call(cbind, lapply(cv_it, function(i) i$M0))
  MLPSearly_df <- do.call(cbind, lapply(cv_it, function(i) i$MLPSearly))
  MLPSlate_df <- do.call(cbind, lapply(cv_it, function(i) i$MLPSlate))
  MLPSIFNg_df <- do.call(cbind, lapply(cv_it, function(i) i$MLPSIFNg))
  MIFNg_df <- do.call(cbind, lapply(cv_it, function(i) i$MIFNg))
  MIL4_df <- do.call(cbind, lapply(cv_it, function(i) i$MIL4))
  MIL10_df <- do.call(cbind, lapply(cv_it, function(i) i$MIL10))
  Mdex_df <- do.call(cbind, lapply(cv_it, function(i) i$Mdex))
  
  return(list(lambda = lambda_df,
              M0 = M0_df,
              MLPSearly = MLPSearly_df,
              MLPSlate = MLPSlate_df,
              MLPSIFNg = MLPSIFNg_df,
              MIFNg = MIFNg_df,
              MIL4 = MIL4_df,
              MIL10 = MIL10_df,
              Mdex = Mdex_df))
}

#For reference and time purposes (our implementation of repeated cross-validation can take a long time), we will import the data if it already exists.

if(!file.exists(file.path(rdataDir, "repeated_cv_training_classifier.Rds"))){
  cl <- makeCluster(8)
  registerDoParallel(cl)
  rep_cv_training <- rep_cv(x = t(training_cl_expression), 
                            y = training_cl_samples$Group, 
                            alpha = 0.8, 
                            family = "multinomial", 
                            standardize = F, 
                            B = 500)
  
  stopCluster(cl)
  
  saveRDS(rep_cv_training, file = file.path(rdataDir, "repeated_cv_training_classifier.Rds"))
} else{
  rep_cv_training <- readRDS(file.path(rdataDir, "repeated_cv_training_classifier.Rds"))
}
```

Having repeated the cross-validation `B` times, we would now want to investigate how our classifier "looks like". To make use of the iterations, we also define "stable predictor genes" as genes whose predicted coefficient was non-zero in 50% of all iterations. We can visualize this by means of a series of boxplots. The `repeated_cv_training_classifier.Rds` as generated during our analysis has been provided as data in the `macIDR` package. 

```{r visualization classifier coefficients boxplot, fig.width = 8, fig.height = 10}
stabilityplotter <- function(macrophage, coefs_list, sort_by_coeff = T){
  #This function will plot boxplots per gene across the iterations. In addition, predictor genes will be defined based on its stability as defined
  
  responses <- coefs_list[[macrophage]][-1,]
  relimp <- apply(responses, 1, function(gene){mean(abs(gene)>0)})
  respmed <- apply(responses, 1, function(gene){median(gene)})
  nz_genes <- which(relimp != 0)
  nz_relimp <- relimp[nz_genes]
  nz_respmed <- respmed[nz_genes]
  nz_genes_melt <- melt(responses[nz_genes,])
  nz_genes_melt$relimp <- rep(nz_relimp, 500)
  nz_genes_melt$respmed <- rep(nz_respmed, 500)
  nz_genes_melt$stable <- factor(nz_genes_melt$relimp > 0.5, levels = c("FALSE", "TRUE"))

  colnames(nz_genes_melt) <- c("Entrez", "Iteration", "Coefficient", "Relimp", "Respmed", "Stable")
  nz_genes_melt$Direction <- NA
  nz_genes_melt$Direction[nz_genes_melt$Stable == "TRUE" & nz_genes_melt$Respmed > 0] <- "Stable Positive"
  nz_genes_melt$Direction[nz_genes_melt$Stable == "TRUE" & nz_genes_melt$Respmed < 0] <- "Stable Negative"
  nz_genes_melt$Direction[nz_genes_melt$Stable == "FALSE"] <- "Unstable"
  nz_genes_melt$Direction <- factor(nz_genes_melt$Direction, levels = c("Stable Negative", "Stable Positive", "Unstable"))
  
  nz_genes_melt$Entrez <- as.character(nz_genes_melt$Entrez)
  nz_genes_melt$Symbol <- mapIds(org.Hs.eg.db,
                                 keys = as.character(nz_genes_melt$Entrez),
                                 column = "SYMBOL",
                                 keytype = "ENTREZID",
                                 multiVals = "first")
  
  if(sort_by_coeff){
    stab_coef <- apply(responses, 1, function(gene){median(gene)})
    sorted_entrez <- data.frame(entrez = names(sort(stab_coef, decreasing = F)), index = 1:length(stab_coef))
    nz_genes_melt <- merge(nz_genes_melt, sorted_entrez, by.x = "Entrez", by.y = "entrez")
    nz_genes_melt$Symbol <- factor(x = nz_genes_melt$Symbol, levels = unique(nz_genes_melt$Symbol[order(nz_genes_melt$index)]))
  }
  
  gplot_obj <- ggplot(nz_genes_melt, aes(x = Symbol, y = Coefficient, col = Direction)) +
    geom_hline(yintercept = 0, linetype="dashed", col = "darkgrey") +
    geom_jitter(alpha = 0.1) +
    geom_boxplot(alpha = 0.5, col = "black", outlier.shape=NA) +
    ylab("Log(OR)") +
    xlab(NULL) +
    coord_flip() +
    theme_bw() +
    ggtitle(macrophage) +
    scale_color_manual(values=c(gg_color_hue(2)[2], gg_color_hue(2)[1], "#D3D3D3")) +
    guides(colour = guide_legend(override.aes = list(alpha = 1))) +
    #scale_colour_discrete(drop = FALSE) +
    theme(panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          legend.title = element_blank())
  
  return(gplot_obj)
}
coefficients_cl <- rep_cv_training[-1]

stabilityplotter("MLPSlate", coefs_list = coefficients_cl)

coefficients_cl_boxplot <- lapply(names(coefficients_cl), stabilityplotter, coefs_list = coefficients_cl)
names(coefficients_cl_boxplot) <- names(coefficients_cl)

# Cairo(file = file.path(clDir, "stabilized_classifier_coefficients.pdf"), type = "pdf", units = "px", width = 2000, height = 2750, dpi = 120, bg = "white")
print(ggarrange(coefficients_cl_boxplot$M0, 
                coefficients_cl_boxplot$MLPSearly, 
                coefficients_cl_boxplot$MLPSlate, 
                coefficients_cl_boxplot$MLPSIFNg, 
                coefficients_cl_boxplot$MIFNg, 
                coefficients_cl_boxplot$MIL4, 
                coefficients_cl_boxplot$MIL10, 
                coefficients_cl_boxplot$Mdex,
                common.legend = TRUE, legend = "bottom", nrow = 2, ncol = 4))
# dev.off()
```

In red and blue we observe the stable predictor genes, which we will use in downstream analyses. We will now extract the median of all iterations per stable predictor gene which we will use to validate our observations on the unseen test set. 

```{r stable coefficient extractions, resuls = "hide"}
stab_selected <- function(exprs, threshold){
  rel_imptance <- apply(exprs, 1, function(gene){mean(abs(gene)>0)})
  stab_genes <- names(which(rel_imptance > threshold))
  return(stab_genes)
}

stab_selected_wrapper <- function(coefs_list, threshold){
  stable_genes <- sapply(names(coefs_list), function(macr){
    macr_coefs <- coefs_list[[macr]]
    stab_selected(macr_coefs, 0.5)
  })
  
  return(stable_genes)
}

stable_predictor_genes <- unique(unlist(stab_selected_wrapper(coefficients_cl, 0.5)))

coefficients_cl_aggregated <- data.frame(do.call(cbind, lapply(coefficients_cl, function(coefs){rowMedians(coefs[stable_predictor_genes,])})), 
                                         row.names = stable_predictor_genes)

rownames(coefficients_cl_aggregated)[-1] <- mapIds(org.Hs.eg.db,
                                                   keys = rownames(coefficients_cl_aggregated)[-1],
                                                   column = "SYMBOL",
                                                   keytype = "ENTREZID",
                                                   multiVals = "first")

write.csv(coefficients_cl_aggregated, file.path(clDir, "median-stabilized_coefficients.csv"))
```

The extraction of the median-stabilized coefficients has been implemented in the `lORStabilizer()` function found in the `macIDR` package in case different parameters (i.e. aggregation function or threshold). 
We have now stored our median-stabilized coefficients in the `stable_predictor_genes` dataframe, which we can visualize easily using a heatmap thereby providing useful information which genes are shared between macrophage activation states.

```{r median-stabilized coefficient heatmap, fid.width = 10, fig.height = 6}
hm_blist <- seq(-1, 1, by = 0.01)

coefficients_cl_aggregated_l2 <- log2(coefficients_cl_aggregated[-1,] + 1)

# Cairo(file = file.path(clDir, "median-stabilized_coefficients.pdf"), type = "pdf", units = "px", width = 3000, height = 800, dpi = 120, bg = "white")
pheatmap(t(coefficients_cl_aggregated_l2),
         cluster_rows = F,
         cluster_cols = T,
         main = "Median-stabilized log(OR)",
         display_numbers = F,
         color = colorRampPalette(c("blue", "white", "red"))(length(hm_blist)),
         breaks = hm_blist)
# dev.off()
```

##Classifier validation

Having constructed the classification model previously, we would now want to see how well it performs on samples it has not seen before namely the test set. Note that at this point, we will utilize the macIDR package as it facilitates certain calculations.

```{r validation classifier unseen data, results = "hide"}
require(macIDR)

stabilized_lor <- lORStabilizer()

test_cl_mcObj <- macClassifier(exprs_data = test_cl_expression, lor_list = stabilized_lor)
test_cl_proportion <- macIDR::getProportion(test_cl_mcObj)
  
test_cl_predict <- names(stabilized_lor)[apply(test_cl_proportion, MARGIN = 1, function(i){which.max(i)})]

classification <- data.frame(predict = test_cl_predict, actual = test_cl_samples$Group)
test_cl_table <- table(classification$predict, classification$actual, dnn = c("predict", "actual"))
test_cl_table_df <- as.data.frame(test_cl_table)

test_cl_confusion <- data.frame(do.call(rbind, lapply(X = names(stabilized_lor), FUN = function(macrophage, freq_table){
  #This function calculates a confusion matrix
  
  confusion_mat <- data.frame(
    TP = sum(freq_table$Freq[which(freq_table$actual == macrophage & freq_table$predict == macrophage)]),
    FP = sum(freq_table$Freq[which(freq_table$actual == macrophage & freq_table$predict != macrophage)]),
    TN = sum(freq_table$Freq[which(freq_table$actual != macrophage & freq_table$predict != macrophage)]), 
    FN = sum((freq_table$Freq[which(freq_table$actual != macrophage & freq_table$predict == macrophage)])))
  confusion_mat$TNR <- with(confusion_mat, TN/(TN + FP))
  confusion_mat$TPR <- with(confusion_mat, TP/(TP + FN))
  confusion_mat$Accuracy <- with(confusion_mat, (TP + TN)/sum(freq_table$Freq))
  return(confusion_mat)
}, freq_table = test_cl_table_df)), row.names = names(stabilized_lor))
```

To investigate how well the classifier performed on the test set, the easiest way is to simply look at the predicted vs true matrix as well as the confusion matrix.

```{r test set statistics}
print(test_cl_confusion)
print(test_cl_table)
```

###Misclassified samples

In total, we found 4 misclassified samples. We next sought to investigate whether we could find any pattern underlying the misclassified samples.

```{r misclassification}
misclassified <- test_cl_samples[which(classification$predict != classification$actual),]
(misclassified$Study)
```

All misclassified samples were obtained from different studies, ruling out a study-specific effect. We find that the M0 class appears to be the most problematic with it being misclassified thrice: M0 has been classified as MIFNg and MIL10, whereas Mdex was classified as M0. We therefore investigated the classification signal to see whether it could provide insight into the potential cause underlying the misclassifications

```{r visualize the misclassified samples, fig.width = 4, fig.height = 4}
misclassified_df <- data.frame(predicted = classification[which(classification$predict != classification$actual), "predict"],
                               actual = classification[which(classification$predict != classification$actual), "actual"],
                               study = misclassified$Study,
                               sample = misclassified$SampleID,
                               test_cl_proportion[misclassified$SampleID,])
misclassified_df_melt <- melt(misclassified_df)
colnames(misclassified_df_melt) <- c("Predict_full", "Actual_full", "Study", "Sample", "Macrophage", "Response")
misclassified_df_melt$Study_sample <- paste0(misclassified_df_melt$Study, ": ", misclassified_df_melt$Sample)

misclassified_df_melt$Colors <- NA
misclassified_df_melt$Colors[which(misclassified_df_melt$Predict_full == misclassified_df_melt$Macrophage)] <- "Predicted"
misclassified_df_melt$Colors[which(misclassified_df_melt$Actual_full == misclassified_df_melt$Macrophage)] <- "Actual"

ggplot(misclassified_df_melt, aes(x = Macrophage, y = Response, group = Sample, fill = Colors)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~Study_sample, nrow = 2, ncol = 2) +
  ylim(0,1) +
  ylab(NULL) +
  xlab(NULL) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title=element_blank(),
        legend.position="bottom")
```

We observe that in the case of samples `exp068.d54D_S13_R1_001`,  `GSM1338795`, and up to some extent `GSM1338795` the classifier was almost right where the second best choice ended up being the actual class. By contrast,  the classifier was confidently wrong for sample `GSM464241`. To investigate this even further, we looked at the log odds at the level of individual genes.

* `exp068.d54D_S13_R1_001`
The sample `exp068.d54D_S13_R1_001` was a Mdex derived from our own RNAseq experiment that was incorrectly classified as M0. In the next chunk we will visually compare all dexamethasone samples from our own RNAseq experiment. We expect that either the log odds for `exp068.d54D_S13_R1_001` is lower for Mdex or higher for M0 relative to `exp068.d55D_S21_R1_001` and `exp068.d57D_S29_R1_001`. 

```{r exp068 dex, fig.width = 7.5, fig.height = 7.5}
Mdex_exp068 <- test_cl_samples[test_cl_samples$StudyID == "exp068" & test_cl_samples$Group == "Mdex","SampleID"]
Mdex_group <- NA
Mdex_group[Mdex_exp068 %in% misclassified$SampleID] <- "Incorrect"
Mdex_group[!Mdex_exp068 %in% misclassified$SampleID] <- "Correct"

macIDR::geneLOddsPlot(scObj = test_cl_mcObj, samples = Mdex_exp068, title = "exp068 Mdex", phenotype = Mdex_group)
```

Visually, we cannot really ascertain why `exp068.d54D_S13_R1_001` (blue) was misclassified whereas `exp068.d55D_S21_R1_001` and `exp068.d57D_S29_R1_001` (red) were not. The only gene that would fit within our expectation is M0: HTR2B. Besides this discrepancy, we observe that VSIG4 and ADORA3 are highly Mdex concordant, possibly explaining the relative similarity when looking at the classification output for M0 and Mdex.

* `GSM464241`
The sample `GSM464241` was a MLPSlate derived from study `GSE18686` that was incorrectly (and arguably quite confidently) classified as MLPSIFNg. As before, we will visually compare all MLPSlate samples from `GSE18686`. Note however that for `GSE18686` some MLPSlate samples were in the training set.

```{r GSE18686 MLPSlate, fig.width = 7.5, fig.height = 7.5}
MLPSlate_GSE18686 <- cl_samples[cl_samples$StudyID == "GSE18686" & cl_samples$Group == "MLPSlate",]
MLPSlate_GSE18686_expression <- cl_expression$GSE18686_GPL6947[, MLPSlate_GSE18686$SampleID]

MLPSlate_GSE18686_mcObj <- macClassifier(MLPSlate_GSE18686_expression, stabilized_lor)
MLPSlate_GSE18686_predictions <- names(stabilized_lor)[apply(getProportion(MLPSlate_GSE18686_mcObj), 1, which.max)]

MLPSlate_GSE18686_group <- rep("Correct", length(MLPSlate_GSE18686_predictions))
MLPSlate_GSE18686_group[MLPSlate_GSE18686_predictions == "MLPSIFNg"] <- "Incorrect"

macIDR::geneLOddsPlot(scObj = MLPSlate_GSE18686_mcObj, samples = MLPSlate_GSE18686$SampleID, title = "GSE18686 MLPSlate", phenotype = MLPSlate_GSE18686_group)
```

Note that there was another error made for this dataset, namely sample `GSM464206`, which was located in the training set. While interesting, we know that MLPSlate resembles M0 in certain aspects, so we will ignore it for now. Sample `GSM464241` was found to display a high expression for EBI3, CXCL9 and up to some extent CXCL10. All of which are predictor genes for MLPSIFNg. 

* `GSM1338795`
The sample `GSM1338795` was a MIFNg derived from study `GSE55536` that was incorrectly classified as M0. As before, we will visually compare all M0 samples from `GSE55536`. Note however that for `GSE55536` there are only two M0 samples the other being in the training set.

```{r GSM1338795 M0, fig.width = 7.5, fig.height = 7.5}
M0_GSE55536 <- cl_samples[cl_samples$StudyID == "GSE55536" & cl_samples$Group == "M0",]
M0_GSE55536_expression <- cl_expression$GSE55536[, M0_GSE55536$SampleID]

M0_GSE55536_mcObj <- macClassifier(M0_GSE55536_expression, stabilized_lor)
M0_GSE55536_predictions <- names(stabilized_lor)[apply(getProportion(M0_GSE55536_mcObj), 1, which.max)]

M0_GSE55536_group <- rep("Correct", length(M0_GSE55536_predictions))
M0_GSE55536_group[M0_GSE55536_predictions != M0_GSE55536$Group] <- "Incorrect"

macIDR::geneLOddsPlot(scObj = M0_GSE55536_mcObj, samples = M0_GSE55536$SampleID, title = "GSE55536 M0", phenotype = M0_GSE55536_group)
```

Similar to sample `GSM464241` sample `GSM1338795` was found to display a high expression for CXCL9 relative to the other GSE55536 M0 sample. 

* `GSM1515655`
The sample `GSM1515655` was a MIL10 derived from study `GSE57614` that was incorrectly classified as M0. As before, we will visually compare all M0 samples from `GSE57614`. 

```{r GSM1338795 M0, fig.width = 7.5, fig.height = 7.5}
M0_GSE57614 <- cl_samples[cl_samples$StudyID == "GSE57614" & cl_samples$Group == "M0",]
M0_GSE57614_expression <- cl_expression$GSE57614[, M0_GSE57614$SampleID]

M0_GSE57614_mcObj <- macClassifier(M0_GSE57614_expression, stabilized_lor)
M0_GSE57614_predictions <- names(stabilized_lor)[apply(getProportion(M0_GSE57614_mcObj), 1, which.max)]

M0_GSE57614_group <- rep("Correct", length(M0_GSE57614_predictions))
M0_GSE57614_group[M0_GSE57614_predictions != M0_GSE57614$Group] <- "Incorrect"

macIDR::geneLOddsPlot(scObj = M0_GSE57614_mcObj, samples = M0_GSE57614$SampleID, title = "GSE57614 M0", phenotype = M0_GSE57614_group)
```

Surprisingly there are two samples that are incorrect, while I see that one sample displays higher MARCO expression, I am surprised the other sample was classified as MIL10 as well. The difference could however be due to NAMPT that appears to be higher in both incorrectly classified samples.

##Classification model extended testing

Having investigated how the built classifier performed on our data, we wanted to test the model on more foreign samples. Specifically, we wanted to see how macrophages differentiated with GM-CSF would perform as well as samples obtained from cells that were not macrophages at all. All of this would eventually pave the way to understanding what limitations we must consider when classifying macrophages *in vivo* as they will undoubtedly look different from their *in vitro* counterparts. For this extended testing, we arranged an additional sample cohort called `Classifier verification`, which we will process and classify in one go using the functions in the `macIDR` package.

```{r verification samples, results = "hide"}
extvalDir <- file.path(clDir, "extended_validation")
dir.create(extvalDir)

verification_samples <- samples[grep("Classifier verification", samples$Cohort),]
verification_studies <- unique(paste0(verification_samples$StudyID, "_", verification_samples$PlatformID))

Scolors <- cbPalette[2:(2+length(verification_studies)-1)]
names(Scolors) <- gsub("(GSE[0-9]+)_GPL[0-9]+", "\\1", verification_studies)
```

```{r verification classification, results = "hide"}
verification_mcObj <- lapply(verification_studies, function(study, expression_list, lor_list){
  study_expression <- exprs(norm_microarray_merged[[study]])
  macClassifier(study_expression, lor_list)
}, expression_list = norm_microarray_merged, lor_list = stabilized_lor)

names(verification_mcObj) <- verification_studies

#Proportions
verification_proportions <- do.call(rbind, lapply(verification_mcObj, getProportion))
verification_proportions <- verification_proportions[verification_samples$SampleID,]
```

Now that we have extracted and ordered the proportions in the same way as the samples, we can visualize what happens in particular cases.

###GM-CSF differentiated macrophages

We trained our classification model on M-CSF differentiated macrophages. Besides M-CSF, GM-CSF is often used as differentiation agent as well. From the literature, GM-CSF macrophages appear to display a more pro-inflammatory phenotype. To this end we sought to investigate whether our classification model would work on GM-CSF differentiated macrophages as well. In other words, are signature genes representative for macrophage activation the same regardless of differentiation agent? Unfortunately we were not able to find gene expression datasets for all GM-CSF differentiated macrophage activation states under similar conditions (think of differentiation time), we only found GM0, GMLPSearly, GMLPSlate, GMLPSIFNg and GMIL4. 

```{r gmcsf samples, results = "hide"}
gm_samples <- verification_samples[grep("GM", verification_samples$Cell),]
gm_proportions <- verification_proportions[gm_samples$SampleID,]
```

```{r gmcsf heatmap}
anno_gm_hm <- data.frame(StudyID = gm_samples$StudyID, 
                         Group = gm_samples$Group, 
                         Prediction = colnames(gm_proportions)[apply(gm_proportions, 1, which.max)])

rownames(gm_proportions) <- rownames(anno_gm_hm) <- paste0(rownames(gm_proportions), " (", gm_samples$Group, ")")
anno_gm_cols <- list(Prediction = Mcolors,
                     StudyID = Scolors)

#Cairo(file = file.path(extvalDir, "gm_classification_heatmap.pdf"), type = "pdf", units = "px", width = 750, height = 1500, dpi = 90, bg = "white")
pheatmap(mat = gm_proportions, 
         annotation_row = anno_gm_hm,
         annotation_colors = anno_gm_cols, 
         cluster_cols = F)
#dev.off()
```

We found the classifier to work well for both M-CSF and the GM-CSF macrophages we could test suggesting that the classification model is differentiation factor agnostic. 

###Non-macrophage cells

We would now want to test the limits of the classification model by investigating how it behaves when we know that the input does not represent actual macrophages. To this end, we obtained gene expression data from T, B, Natural Killer (NK), Neutrophils (NP), Fibroblast-like synoviocytes (FLS) and Dendritic cells (DC). Some of the data was obtained from studies that profiled both macrophages and other immune cells, facilitating downstream analyses.

```{r non macrophage samples, results = "hide"}
nm_samples <- verification_samples[-grep("GM", verification_samples$Cell),]
nm_proportions <- verification_proportions[nm_samples$SampleID,]
```

```{r non macrophage heatmap}
anno_nm_hm <- data.frame(StudyID = nm_samples$StudyID, 
                         Cell = nm_samples$Cell, 
                         Prediction = colnames(nm_proportions)[apply(nm_proportions, 1, which.max)])

rownames(nm_proportions) <- rownames(anno_nm_hm) <- paste0(rownames(nm_proportions), " (", nm_samples$Group, ")")
anno_nm_cols <- list(Prediction = Mcolors,
                     StudyID = Scolors)

#Cairo(file = file.path(extvalDir, "nm_classification_heatmap.pdf"), type = "pdf", units = "px", width = 750, height = 1500, dpi = 90, bg = "white")
pheatmap(mat = nm_proportions, 
         annotation_row = anno_nm_hm,
         annotation_colors = anno_nm_cols, 
         cluster_cols = F)
#dev.off()
```

While the heatmap is practically illegible, it shows that a large chunk of non-macrophage cells are classified as M0, DCs are classified as MIL4, and some are classified as MLPSlate. The observation that DCs are classified as MIL4 is perhaps not entirely strange as DCs are generally created by maturing monocytes with IL4. While most DCs were all obtained from a single study, some of the GM-CSF treated macrophages from above were obtained from the same study, which were classified correctly.
The question thus arises, why did the classifier consider all non-macrophage cells to be M0? and can we distinguish proper M0 classifications from the non-macrophage classifications. I believe that answering the second question might provide some insights into the first question. To this end, we must take a step back and look at the log odds of the classifications for the true M0 classifications as well as those obtained from the extended validation set.

```{r M0 log odds distribution}
training_cl_mcObj <- macClassifier(exprs_data = training_cl_expression, lor_list = stabilized_lor)
training_cl_lodds <- getLOdds(training_cl_mcObj)
training_samples_M0 <- training_cl_samples[training_cl_samples$Group == "M0",]

test_cl_mcObj <- macClassifier(exprs_data = test_cl_expression, lor_list = stabilized_lor)
test_cl_lodds <- getLOdds(test_cl_mcObj)
test_samples_M0 <- test_cl_samples[test_cl_samples$Group == "M0",]

verification_lodds <- do.call(rbind, lapply(verification_mcObj, getLOdds))
verification_lodds <- verification_lodds[verification_samples$SampleID,]

m0_lodds_distribution <- data.frame(lodds = c(training_cl_lodds[training_samples_M0$SampleID, "M0"],
                                              test_cl_lodds[test_samples_M0$SampleID, "M0"],
                                              verification_lodds[, "M0"]),
                                    StudyID = c(rep("Training", nrow(training_samples_M0)),
                                                rep("Test", nrow(test_samples_M0)),
                                                verification_samples$StudyID),
                                    Cell = c(rep("M0", nrow(training_samples_M0)),
                                             rep("M0", nrow(test_samples_M0)),
                                             verification_samples$Cell),
                                    Group = c(rep("M0", nrow(training_samples_M0)),
                                              rep("M0", nrow(test_samples_M0)),
                                              verification_samples$Group),
                                    Platform = c(training_samples_M0$PlatformID,
                                                 test_samples_M0$PlatformID,
                                                 verification_samples$PlatformID))
Scolors_ext <- c("Training" = "#f99393", 
                 "Test" = "#91eef7", 
                 Scolors)

m0_lodds_distribution$Cell <- factor(m0_lodds_distribution$Cell, levels = c("M0", "GM", "DC", "FLS", "B", "T", "NK", "NP"))

#Main plot
m0_lodds_distribution_mainplot <- ggplot(m0_lodds_distribution, aes(x = Cell, y = lodds)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(aes(col = StudyID)) +
  ggtitle("M0 signal: GMDMs and non-MDMs") +
  scale_colour_manual(values = Scolors_ext) +
  xlab("") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#Subplot
m0_lodds_distribution_sub <- m0_lodds_distribution[grep("(M0|GM|DC)", m0_lodds_distribution$Group),]

m0_lodds_distribution_sub$Group <- factor(m0_lodds_distribution_sub$Group, levels = c("M0", "GM0", "GMLPSearly", "GMLPSlate", "GMIFNg", "GMIL4", "DC0", "DCLPSlate", "DCTNF", "DCTPP"))

m0_lodd_distribution_subplot <- ggplot(m0_lodds_distribution_sub, aes(x = Group, y = lodds)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(aes(col = StudyID)) +
  ggtitle("M0 signal: GMDM and DC") +
  scale_colour_manual(values = Scolors_ext) +
  xlab("") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggarrange(m0_lodds_distribution_mainplot, m0_lodd_distribution_subplot, common.legend = T, legend = "right", ncol = 1, nrow = 2)
```

We observe that GMs and DCs appear to display a reasonably similar M0 distribution as proper M0s and that this is dependent on the type of activation after differentiation/maturation. Non-MDMs however *can* display a slightly lower distribution, but that there is no clear boundary to be drawn.

```{r summary extended validation}
verification_proportions_df <- data.frame(verification_proportions, 
                                          Cell = verification_samples$Cell,
                                          Group = verification_samples$Group,
                                          StudyID = verification_samples$StudyID,
                                          SampleID = verification_samples$SampleID)

verification_proportions_melt <- reshape2::melt(verification_proportions_df, varnames = c("Cell", "StudyID", "SampleID", "Group", "Class"), value.name = "Proportion")

verification_proportions_melt$Cell <- factor(verification_proportions_melt$Cell, levels = c("GM", "DC", "FLS", "B", "T", "NK", "NP"))

verification_proportions_allplot <- ggplot(verification_proportions_melt, aes(x = variable, y = Proportion, col = Cell)) +
  geom_point(alpha = 0.5, position = position_jitterdodge()) +
  geom_boxplot(alpha = 0.5, outlier.shape=NA) +
  xlab("") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.pos = "bottom")

verification_proportions_melt_dc <- verification_proportions_melt[verification_proportions_melt$Cell == "DC",]

verification_proportions_dcplot <- ggplot(verification_proportions_melt_dc, aes(x = variable, y = Proportion, col = Group)) +
  geom_point(alpha = 0.5, position = position_jitterdodge()) +
  geom_boxplot(alpha = 0.5, outlier.shape=NA) +
  xlab("") +
  ggtitle("DC") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.pos = "bottom")

verification_proportions_melt_gm <- verification_proportions_melt[verification_proportions_melt$Cell == "GM",]

verification_proportions_gmplot <- ggplot(verification_proportions_melt_gm, aes(x = variable, y = Proportion, col = Group)) +
  geom_point(alpha = 0.5, position = position_jitterdodge()) +
  geom_boxplot(alpha = 0.5, outlier.shape=NA) +
  xlab("") +
  ggtitle("GM") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.pos = "bottom")

verification_proportions_subplot <- ggarrange(verification_proportions_gmplot, verification_proportions_dcplot, nrow = 1, ncol = 2)
verification_proportions_leftplot <- ggarrange(verification_proportions_allplot, verification_proportions_subplot, nrow = 2, ncol = 1)
verification_proportions_rightplot <- ggarrange(m0_lodds_distribution_mainplot, m0_lodd_distribution_subplot, common.legend = T, legend = "right", ncol = 1, nrow = 2)

verification_proportions_plot <- ggarrange(verification_proportions_leftplot, verification_proportions_rightplot, labels = c("A", "B"), nrow = 1, ncol = 2)

Cairo(file = file.path(extvalDir, "extended_validation.pdf"), type = "pdf", units = "px", width = 2000, height = 1000, dpi = 90, bg = "white")
ggarrange(verification_proportions_leftplot, verification_proportions_rightplot, labels = c("A", "B"), nrow = 1, ncol = 2)
dev.off()
```

We have thus observed that the non-macrophage cells are almost exclusively classified as M0, GM-CSF differentiated macrophages are on the other hand classified according to their M-CSF counterparts. While the non-macrophage cells are classified as M0, it appears that we can somewhat make a distinction between "proper" M0 and "improper" M0 classification, but that no defining line can be drawn.

##*In vivo* macrophages

Having validated macIDR extensively in the previous sections, we would now put it to the test by actually classifying macrophages obtained from an in vivo source. 

```{r in vivo macrophages, results = "hide"}
ivDir <- file.path(clDir, "in_vivo")
dir.create(ivDir)

invivo_samples <- samples[grep("In vivo testing", samples$Cohort),]
invivo_studies <- unique(paste0(invivo_samples$StudyID, "_", invivo_samples$PlatformID))
```

```{r in vivo classification, results = "hide"}
invivo_mcObj <- lapply(invivo_studies, function(study, expression_list, lor_list){
  study_expression <- exprs(norm_microarray_merged[[study]])
  macClassifier(study_expression, lor_list)
}, expression_list = norm_microarray_merged, lor_list = stabilized_lor)

names(invivo_mcObj) <- invivo_studies

#Proportions
invivo_proportions <- do.call(rbind, lapply(invivo_mcObj, getProportion))
invivo_proportions <- invivo_proportions[invivo_samples$SampleID,]
```

###Synovial macrophages

The synovial macrophages are usually extracted as part of a biopsy when patients are diagnosed with rheumatoid arthritis (RA). RA is characterized by immune cell infiltration of the synovial lining. Macrophages from the synovium were studied in `GSE97779`, `GSE10500`, `MEXP3890`, and `GSE49604`.

```{r synovial macrophage setup and samples, results = "hide"}
smDir <- file.path(ivDir, "synovial_macrophages")
dir.create(smDir)

sm_samples <- invivo_samples[invivo_samples$Cell %in% "SM",]
sm_studies <- unique(sm_samples$StudyID)
```

Note that not every study has `Healthy Control` samples.

```{r synovial macrophage samples per study}
table(sm_samples$Group, sm_samples$StudyID)
```

```{r synovial macrophage predictions}
sm_rowanno <- data.frame(Group = sm_samples$Group, 
                         Study = sm_samples$StudyID,
                         row.names = sm_samples$SampleID)

pheatmap(invivo_proportions[sm_samples$SampleID, ], cluster_cols = F, annotation_row = sm_rowanno)
```

We observe that healthy controls are generally classified as M0, whereas RA-derived synovial macrophages are either classified as MIFNg or MIL10. However, this is not a good way of comparing the data. The reason is that the proportions as depicted above always sum to 1. Instead, the log odds might be more representative. To this end, it might be more useful to use the `sparseClassification` object we stored in `invivo_mcObj`. In addition, it appears that one study misses a few of the predictor genes, so we would want to give a metric (the relative log odds ratio) to show how much of the model is present.

```{r synovial macrophage log odds}
sm_mcObj <- invivo_mcObj[unique(paste0(sm_samples$StudyID, "_", sm_samples$PlatformID))]
sm_lodds <- do.call(rbind, lapply(sm_mcObj, getLOdds))

#Relative log odds ratio
sm_ps <- do.call(cbind, lapply(sm_mcObj, function(mcobj){
  data.frame(ps = getPresenceStats(mcobj)$logOR_relative, row.names = rownames(getPresenceStats(mcobj)))
}))
colnames(sm_ps) <- gsub("(.+)_.+", "\\1", names(sm_mcObj))
sm_ps$Class <- rownames(sm_ps)
sm_ps <- reshape2::melt(sm_ps, varnames = c("Class", "StudyID"), value.name = "rlogOR")

sm_df <- reshape2::melt(sm_lodds, varnames = c("SampleID", "Class"), value.name = "Lodds")
sm_df$Group <- sm_samples[match(sm_df$SampleID, sm_samples$SampleID), "Group"]
sm_df$StudyID <- sm_samples[match(sm_df$SampleID, sm_samples$SampleID), "StudyID"]
sm_df <- merge(sm_df, sm_ps, by.x = c("Class", "StudyID"), by.y = c("Class", "variable"))
sm_df$Class <- factor(sm_df$Class, levels = names(Mcolors))

sm_melt_rf <- sm_df %>% 
  group_by(.dots=c("StudyID", "Class", "Group", "rlogOR")) %>% 
  summarise(
    avg = mean(Lodds),
    se = sd(Lodds)/sqrt(length(Lodds))
  )

sm_range <- abs(ceiling(abs(diff(with(sm_melt_rf, c(ceiling(max(avg+se)), floor(min(avg-se))))))/10))*10

#Cairo(file = file.path(smDir, "Synovial_macrophage_logodds.pdf"), type = "pdf", units = "px", width = 700*4, height = 700, dpi = 120, bg = "white")
ggplot(sm_melt_rf, aes(x = Class, y = avg)) +
  geom_crossbar(aes(ymin = avg-se, ymax = avg+se, col = Group), width = 0.8, position = position_dodge(), stat = "identity") +
  ylab("Total log odds") +
  geom_point(aes(y = rlogOR*sm_range), stat = "identity") +
  scale_y_continuous(sec.axis = sec_axis(~./sm_range, name = "rlogOR")) +
  facet_wrap(~ StudyID, ncol = 4) +
  theme_bw() +
  ggtitle("Synovial macrophages") + 
  theme(legend.position="bottom",
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_blank(),
        legend.title = element_blank()) 
#dev.off()
```

We observe that the synovial macrophages show a different pattern depending on whether a person is healthy* or has rheumatoid arthritis. The healthy SMs appear to be more M0-like (as we concluded previously), whereas the RA-associated SMs are more MIFNg or MIL10 like. The question is still however, which genes are responsible for this classification?
*: The samples labeled as "Healthy" were simply MDMs as synovial biopsies are generally not obtained from healthy individuals.

```{r synovial macrophage gene log odds}
geneLOddsPlot(sm_mcObj$GSE10500_GPL8300, phenotype = sm_samples[sm_samples$StudyID == "GSE10500","Group"])
geneLOddsPlot(sm_mcObj$GSE49604_GPL8432, phenotype = sm_samples[sm_samples$StudyID == "GSE49604","Group"])
geneLOddsPlot(sm_mcObj$GSE97779_GPL570, phenotype = sm_samples[sm_samples$StudyID == "GSE97779","Group"])
geneLOddsPlot(sm_mcObj$MEXP3890_AAFFY44, phenotype = sm_samples[sm_samples$StudyID == "MEXP3890","Group"])
```

We note that IFNg differences in classification appear to be driven by CXCL9 and up to some extent G0S2, whereas the IL10 classificaiton appears to be driven by MARCO.

###Visceral adipose tissue macrophages

The visceral adipose tissue macrophages (ATMs) were extracted from obese patients. Some of these patients had diabetes (N = 6), whereas the others (N = 6) did not. Specifically, ATMs were obtained from studies `GSE54350`.

```{r adipose tissue macrophage setup and samples, results = "hide"}
atmDir <- file.path(ivDir, "adipose_tissue_macrophages")
dir.create(atmDir)

atm_samples <- invivo_samples[invivo_samples$Cell %in% "ATM",]
atm_studies <- unique(atm_samples$StudyID)
```

Unlike the synovial macrophages, let's skip right to the log odds as the log odds conveys the same message as the proportions but also provides information on the relative differences between class predictions. 

```{r adipose tissue macrophage log odds}
atm_mcObj <- invivo_mcObj[unique(paste0(atm_samples$StudyID, "_", atm_samples$PlatformID))]
atm_lodds <- do.call(rbind, lapply(atm_mcObj, getLOdds))

#Relative log odds ratio
atm_ps <- do.call(cbind, lapply(atm_mcObj, function(mcobj){
  data.frame(ps = getPresenceStats(mcobj)$logOR_relative, row.names = rownames(getPresenceStats(mcobj)))
}))
colnames(atm_ps) <- gsub("(.+)_.+", "\\1", names(atm_mcObj))
atm_ps$Class <- rownames(atm_ps)
atm_ps <- reshape2::melt(atm_ps, varnames = c("Class", "StudyID"), value.name = "rlogOR")

atm_df <- reshape2::melt(atm_lodds, varnames = c("SampleID", "Class"), value.name = "Lodds")
atm_df$Group <- atm_samples[match(atm_df$SampleID, atm_samples$SampleID), "Group"]
atm_df$StudyID <- atm_samples[match(atm_df$SampleID, atm_samples$SampleID), "StudyID"]
atm_df <- merge(atm_df, atm_ps, by.x = c("Class", "StudyID"), by.y = c("Class", "variable"))
atm_df$Class <- factor(atm_df$Class, levels = names(Mcolors))

atm_melt_rf <- atm_df %>% 
  group_by(.dots=c("StudyID", "Class", "Group", "rlogOR")) %>% 
  summarise(
    avg = mean(Lodds),
    se = sd(Lodds)/sqrt(length(Lodds))
  )

atm_range <- abs(ceiling(abs(diff(with(atm_melt_rf, c(ceiling(max(avg+se)), floor(min(avg-se))))))/10))*10

#Cairo(file = file.path(atmDir, "Adipose_tissue_macrophage_logodds.pdf"), type = "pdf", units = "px", width = 700*1, height = 700, dpi = 120, bg = "white")
ggplot(atm_melt_rf, aes(x = Class, y = avg)) +
  geom_crossbar(aes(ymin = avg-se, ymax = avg+se, col = Group), width = 0.8, position = position_dodge(), stat = "identity") +
  ylab("Total log odds") +
  geom_point(aes(y = rlogOR*atm_range), stat = "identity") +
  scale_y_continuous(sec.axis = sec_axis(~./atm_range, name = "rlogOR")) +
  facet_wrap(~ StudyID, ncol = 4) +
  theme_bw() +
  ggtitle("Adipose tissue macrophages") + 
  theme(legend.position="bottom",
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_blank(),
        legend.title = element_blank()) 
#dev.off()
```

```{r adipose tissue macrophage gene log odds}
geneLOddsPlot(atm_mcObj$GSE54350_GPL10558, phenotype = atm_samples[atm_samples$StudyID == "GSE54350","Group"])
```

The LPSearly signal appears to be driven by PTX3 and TNF. Note that we also appear to see some differences for CXCL9 (MIFNg) andVSIG4 (Mdex).

###Alveolar macrophages

The alveolar macrophages (AMs) were extracted from chronic obstructive pulmonary disease (COPD), asthma (both steroid resistant and steroid sensitive) patients, smokers and healthy controls. Specifically, AMs were obtained from studies `GSE2125`, `GSE22528`, `GSE7368`, and `GSE13896`.

```{r alveolar macrophage setup and samples, results = "hide"}
amDir <- file.path(ivDir, "alveolar_macrophages")
dir.create(amDir)

am_samples <- invivo_samples[invivo_samples$Cell %in% "AM",]
am_studies <- unique(am_samples$StudyID)
```

```{r alveolar macrophage log odds}
am_mcObj <- invivo_mcObj[unique(paste0(am_samples$StudyID, "_", am_samples$PlatformID))]
am_lodds <- do.call(rbind, lapply(am_mcObj, getLOdds))

#Relative log odds ratio
am_ps <- do.call(cbind, lapply(am_mcObj, function(mcobj){
  data.frame(ps = getPresenceStats(mcobj)$logOR_relative, row.names = rownames(getPresenceStats(mcobj)))
}))
colnames(am_ps) <- gsub("(.+)_.+", "\\1", names(am_mcObj))
am_ps$Class <- rownames(am_ps)
am_ps <- reshape2::melt(am_ps, varnames = c("Class", "StudyID"), value.name = "rlogOR")

am_df <- reshape2::melt(am_lodds, varnames = c("SampleID", "Class"), value.name = "Lodds")
am_df$Group <- am_samples[match(am_df$SampleID, am_samples$SampleID), "Group"]
am_df$StudyID <- am_samples[match(am_df$SampleID, am_samples$SampleID), "StudyID"]
am_df <- merge(am_df, am_ps, by.x = c("Class", "StudyID"), by.y = c("Class", "variable"))
am_df$Class <- factor(am_df$Class, levels = names(Mcolors))

am_melt_rf <- am_df %>% 
  group_by(.dots=c("StudyID", "Class", "Group", "rlogOR")) %>% 
  summarise(
    avg = mean(Lodds),
    se = sd(Lodds)/sqrt(length(Lodds))
  )

am_melt_rf$Group <- factor(am_melt_rf$Group, levels = c("Healthy Control", "Chronic Obstructive Pulmonary Disease", "Smoker", "Asthma", "Steroid Resistant Asthma", "Steroid Sensitive Asthma"))

am_range <- abs(ceiling(abs(diff(with(am_melt_rf, c(ceiling(max(avg+se)), floor(min(avg-se))))))/10))*10

#Cairo(file = file.path(amDir, "Alveolar_macrophage_logodds.pdf"), type = "pdf", units = "px", width = 700*4, height = 700, dpi = 120, bg = "white")
ggplot(am_melt_rf, aes(x = Class, y = avg)) +
  geom_crossbar(aes(ymin = avg-se, ymax = avg+se, col = Group), width = 0.8, position = position_dodge(), stat = "identity") +
  ylab("Total log odds") +
  geom_point(aes(y = rlogOR*am_range), stat = "identity") +
  scale_y_continuous(sec.axis = sec_axis(~./am_range, name = "rlogOR")) +
  facet_wrap(~ StudyID, ncol = 4) +
  theme_bw() +
  ggtitle("Alveolar macrophages") + 
  theme(legend.position="bottom",
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_blank(),
        legend.title = element_blank()) 
#dev.off()
```

```{r alveolar macrophage gene log odds}
geneLOddsPlot(am_mcObj$GSE2125_GPL570, phenotype = am_samples[am_samples$StudyID == "GSE2125","Group"])
geneLOddsPlot(am_mcObj$GSE22528_GPL96, phenotype = am_samples[am_samples$StudyID == "GSE22528","Group"])
geneLOddsPlot(am_mcObj$GSE7368_GPL570, phenotype = am_samples[am_samples$StudyID == "GSE7368","Group"])
geneLOddsPlot(am_mcObj$GSE13896_GPL570, phenotype = am_samples[am_samples$StudyID == "GSE13896","Group"])
```

There are multiple comparisons to be made on this end, what is observed is that COPD patients are less MIFNg-like which is primarily caused by the lower CXCL9 expression. Coversely, they show some degree of increase in MIL4 genes CCL18 and CXCL5. Asthma by itself does not reveal large differences, however when looking at the steroid sensitive population, they appear to be less IFNg-like due to CXCL9 expression. Notably, also TNF (LPSearly) appears to be lower in the steroid sensitive population. 

#scRNAseq

We previously observed that our classifier `macIDR` worked for bulk *in vitro* RNAseq and microarray. We then classified particular *in vivo* macrophages to investigate their similarity to the eight *in vitro* macrophages. In this analysis, I seek to investigate whether our *in vivo* predictions can be matched at the level of single cells by using a single cell RNAseq (scRNAseq) dataset on synovial biopsies obtained from rheumatoid arthritis patients (see [Stephenson et al. 2018](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5824814/), where the authors had published their data on dbGap [phs001529.v1.p1](https://www.ncbi.nlm.nih.gov/projects/gap/cgi-bin/study.cgi?study_id=phs001529.v1.p1#restricted-access-section) under controlled access). Essentially, this encompasses two questions:
1. Does `macIDR` work on scRNAseq?
2. Do the predictions we made previously on synovial macrophages obtained from RA match the observations made at single cell level? 

I expect that the distribution of scRNAseq will be very different due to the fewer reads per sample as compared to bulk RNAseq. Fewer number of reads will result in a different post-`log2` transformation distribution, where the mode of the graph will likely move closer to zero. As the mode will move closer to zero, the class log odds of the individual genes will move closer to zero as well, resulting in the class with the largest absolute intercept being the prediction, which in our case is MLPSlate. One way of solving this is by ignoring the intercept.

The data by Stephenson et al. as phs001529.v1.p1 pertained count data annotated with gene symbols (note that some of the names have been converted to dates, likely due to some person opening and saving the file in Excel). The alignment and preprocessing have therefore already been completed up to some extent and cannot be modified. 

The goal is to extract the cells identified as macrophages and to perform scRNAseq on them using our classifier under different conditions. As several of the co-authors of Stephenson et al. are on the team that designed the Seurat package, we will use their package to stay as close to their interpretation of the data as possible.

```{r scrnaseq setup, results = "hide", message = F}
scrnaseqDir <- file.path(dataDir, "scrnaseq")
```

```{r seurat import, results = "hide", message = F}
scrasyn <- read.csv(file.path(scrnaseqDir, "nonnormalized", "RA_5Knees_Expression_Matrix.csv"), sep = ",", row.names = 1)
scrasyn <- CreateSeuratObject(raw.data = scrasyn, project = "SC_RASYN", min.cells = 5)
```

Quality control will be done by normalizing for the number of mitochondrial genes as can be found in the [Seurat tutorial](https://satijalab.org/seurat/pbmc3k_tutorial.html). 

```{r scrnaseq quality control, message = F}
#Mitochondrial genes
mc_genes <- grep(pattern = "^MT-", x = rownames(x = scrasyn@data), value = T)
percent_mc <- Matrix::colSums(scrasyn@raw.data[mc_genes, ])/Matrix::colSums(scrasyn@raw.data)

scrasyn <- AddMetaData(object = scrasyn, metadata = percent_mc, col.name = "percent.mito")
```

```{r scrnaseq overall count statistics, message = F}
VlnPlot(object = scrasyn, features.plot = c("nGene", "nUMI", "percent.mito"), nCol = 3)
```

We expect the number of mitochondria-associated reads to be similar across patients of origin if they were sampled randomly.

```{r scrnaseq mitochondria count statistics, message = F}
par(mfrow = c(1,2))
GenePlot(object = scrasyn, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = scrasyn, gene1 = "nUMI", gene2 = "nGene")
```

There appear to be some effects associated to the source with RA2 and RA5 having overall higher levels of genes per cell. Nonetheless, the percentage of mitochondrial genes is reasonably similar. We will therefore scale the data and remove unwanted variation using the number of mitochondria-associated reads as variable.

```{r scrnaseq normalization, results = "hide", message = F}
scrasyn <- NormalizeData(object = scrasyn, normalization.method = "LogNormalize", scale.factor = 10000)
```

In the downstream steps we will perform principal component analysis (PCA). Due to the relatively high dimensionality of the dataset, it is computationally easier to precalculate the variable genes and to use that for PCA. 

```{r scrnaseq identify variable genes, results = "hide", message = F}
scrasyn <- FindVariableGenes(object = scrasyn, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5)
```

```{r scrnaseq scale data, results = "hide", message = F}
scrasyn <- ScaleData(object = scrasyn, vars.to.regress = c("nUMI", "percent.mito"))
```

##Clustering analysis

In the next couple of steps, we will perform clustering analyses on the scRNAseq data to identify the macrophages.

###Unsupervised clustering analysis

```{r scrnaseq unsupervised cluster analysis, results = "hide", message = F}
scrasyn_us <- RunPCA(object = scrasyn, pc.genes = scrasyn@var.genes, do.print = F)
scrasyn_us <- ProjectPCA(object = scrasyn_us)

scrasyn_us <- FindClusters(object = scrasyn_us, reduction.type = "pca", dims.use = 1:13, resolution = 0.6, print.output = 0, save.SNN = T)
```

```{r scrnaseq pca, message = F}
scrnaseq_pca <- PCAPlot(object = scrasyn_us, dim.1. = 1, dim.2 = 2, do.return = T)
print(scrnaseq_pca)
```

While PCA is good for visualizing global distances, it does not do a good job at visualizing near neighbors, which is what t-distributed stochastic neighbor embedding (t-SNE) can do. Computationally speaking, tSNE is quite heavy and so we must first perform dimension reduction first prior to tSNE. We will therefore select a few PCs for subsequent tSNE visualization. Based on the figures presented in Stephenson et al., we observe that they had 13 clusters, which likely corresponds to the first 13 principal components. 

```{r scrnaseq clustering according to stephenson, results = "hide", message = F}
scrasyn_us <- FindClusters(object = scrasyn_us, reduction.type = "pca", dims.use = 1:13, resolution = 0.6, print.output = 0, save.SNN = T)
```

In the next chunks we will use tSNE to visualize the clusters. Note that we don't use tSNE to define our clusters. For an overview on the pitfalls on tSNE and clustering, I recommend [this blogpost](https://distill.pub/2016/misread-tsne/).

```{r scrnaseq tsne, message = F}
scrasyn_us_plot <- scrasyn_us

scrasyn_us <- RunTSNE(object = scrasyn_us_plot, dims.use = 1:13, do.fast = T)

scrasyn_us_plot_cl <- as.factor(paste0("Scl", scrasyn_us_plot@ident))
names(scrasyn_us_plot_cl) <- names(scrasyn_us_plot@ident)

scrasyn_us_plot@ident <- scrasyn_us_plot_cl

scrnaseq_tsne <- TSNEPlot(object = scrasyn_us_plot, do.return = T, do.label = F) + theme(legend.position="bottom")
print(scrnaseq_tsne)
```

Based on the tSNE plot and the article, we believe cluster `0` to be the macrophages. To confirm this, we can use some of the genes Stephenson et al. identified as macrophage marker genes.

```{r scrnaseq macrophage cluster identification, message = F}
scrnaseq_tsne_mac_mark <- FeaturePlot(scrasyn_us, 
                                      features.plot = c("SPI1", "C1QB", "CD14", "CD68", "CSF1R"), 
                                      min.cutoff = "q05", 
                                      max.cutoff = "q95", 
                                      cols.use = c("lightgrey", "blue"), 
                                      pt.size = 0.5, do.return = T)
```

It appears to be the case that indeed this cluster is the most focal point for macrophages. Save the data for later use as the analyses become quite lengthy.

```{r scrnaseq normalized save, results = "hide", message = F}
scrnaseqnormDir <- file.path(scrnaseqDir, "normalized")
dir.create(scrnaseqnormDir)

saveRDS(scrasyn_us, file.path(scrnaseqnormDir, "scrasyn_normalized.Rds"))
```

###Macrophage specific clustering analysis

Having identified cluster `0` as the putative macrophage cluster, we will perform our subsequent analyses on this subset in particular. Our goal is to see whether we can classify the macrophages using `macIDR` and whether the clustering coincides with the predicted macrophage activation states from the previous RA-derived SMs.

```{r scrnaseq macrophage cluster extraction, results = "hide", message = F}
scrasyn_mac <- SubsetData(object = scrasyn_us, ident.use = 0)
```

We investigate which of the predictor genes are present in the data.

```{r scrnaseq predictor gene representation, results = "hide", message = F}
stabilized_lor <- lORStabilizer()

scrasyn_mac_norm_genes <- mapIds(org.Hs.eg.db,
                                 keys = rownames(scrasyn_mac@scale.data),
                                 column = "ENTREZID",
                                 keytype = "SYMBOL",
                                 multiVals = "first")

predictor_genes <- unique(unlist(lapply(stabilized_lor, names)))[-1]

table(predictor_genes %in% scrasyn_mac_norm_genes)

predictor_genes[!predictor_genes %in% scrasyn_mac_norm_genes]
```

Only one gene is not present in the scRNAseq data, namely [FCMR (9214)](https://www.ncbi.nlm.nih.gov/gene/9214), which is a predictor for M0.

###Macrophage scaled cell data classification

We extract the scaled data and perform our classification analysis thereon.

```{r scrnaseq macidr classification, message = F}
scrasyn_mac_norm <- scrasyn_mac@scale.data
rownames(scrasyn_mac_norm) <- mapIds(org.Hs.eg.db,
                                     keys = rownames(scrasyn_mac_norm),
                                     column = "ENTREZID",
                                     keytype = "SYMBOL",
                                     multiVals = "first")

scrasyn_mac_mcObj <- macClassifier(exprs_data = scrasyn_mac_norm, lor_list = stabilized_lor, intercept = T)
scrasyn_mac_prop <- getProportion(scrasyn_mac_mcObj)

table(colnames(scrasyn_mac_prop)[apply(scrasyn_mac_prop, 1, which.max)])
```

As expected, most samples have been classified as MLPSlate, which is likely due to the nature of the distribution. We will therefore remove the intercept from the classification.

```{r scrnaseq macidr classification non-intercept, message = F}
scrasyn_mac_ni_mcObj <- macClassifier(exprs_data = scrasyn_mac_norm, lor_list = stabilized_lor, intercept = F)
scrasyn_mac_ni_prop <- getProportion(scrasyn_mac_ni_mcObj)
scrasyn_mac_ni_lodds <- getLOdds(scrasyn_mac_ni_mcObj)

scrasyn_mac_ni_preds <- colnames(scrasyn_mac_ni_prop)[apply(scrasyn_mac_ni_prop, 1, which.max)]
names(scrasyn_mac_ni_preds) <- rownames(scrasyn_mac_ni_prop)
```

Unlike before, we now have a more even distribution of the different classes, with MIL10 being the class with most predictions.

```{r scrnaseq visualization of the clustering of the samples, message = F}
scrasyn_mac@ident <- factor(scrasyn_mac_ni_preds, levels = names(Mcolors))

#PCA
scrasyn_mac_pca <- PCAPlot(object = scrasyn_mac, dim.1. = 1, dim.2 = 2, do.return = T) + scale_color_manual(values = Mcolors)
print(scrasyn_mac_pca)

#tSNE
scrasyn_mac_tsne <- TSNEPlot(object = scrasyn_mac, do.return = T) + scale_color_manual(values = Mcolors)
print(scrasyn_mac_tsne)
```

We observe that the clusters formed by PCA nor tSNE separate according to the predicted classes. However, the PCA suggests that the predicted MIFNg, MIL4, MIL10, and up to some extent Mdex and MLPSlate display a larger spread across PC2. This appears to be recapitulated as small clusters on tSNE with MIFNg being visibly enriched in a particular cluster.

###MIL10 predictor genes

Having observed that most of the purported macrophages were classified as MIL10, we seek to understand which of the predictor genes is responsible for the classification. We first need to extract the MIL10 predicted macrophages from the entire set.

```{r scrnaseq macidr predictor genes, results = "hide", message = F}
scrasyn_mac_ni_pgenes <- macIDR::geneLOddsExtractor(scrasyn_mac_ni_mcObj)
```

```{r scrnaseq macidr mil10 genes, message = F}
scrasyn_mil10_ni_preds <- names(scrasyn_mac_ni_preds)[scrasyn_mac_ni_preds == "MIL10"]

scrasyn_mil10_ni_pgenes <- scrasyn_mac_ni_pgenes[,scrasyn_mil10_ni_preds]
scrasyn_mil10_ni_mil10genes <- scrasyn_mil10_ni_pgenes[grep("MIL10", rownames(scrasyn_mac_ni_pgenes)),]
scrasyn_mil10_ni_mil10genes <- scrasyn_mil10_ni_mil10genes[-1,]

scrasyn_mil10_ni_topgenes <- gsub("MIL10\\.", "", rownames(scrasyn_mil10_ni_mil10genes)[apply(scrasyn_mil10_ni_mil10genes, 2, function(racell){which.max(racell)})])
(scrasyn_mil10_ni_topgenes <- sort(table(mapIds(org.Hs.eg.db,                                     
                                                keys = scrasyn_mil10_ni_topgenes,
                                                column = "SYMBOL",
                                                keytype = "ENTREZID",
                                                multiVals = "first"))))
```

As expected, the strongest concordant gene expression is MARCO (8685) in most cases. Notably, NAMPT (10135) is also found to be a strong MIL10 predictor.

```{r scrnaseq mil10 predictor genes tsne, message = F}
FeaturePlot(scrasyn_mac, 
            features.plot = c("MARCO", "NAMPT"), 
            min.cutoff = "q05", 
            max.cutoff = "q95", 
            cols.use = c("lightgrey", "blue"), 
            pt.size = 0.5)
```

Interestingly, the expression of MARCO and NAMPT do not appear to coincide, suggesting that cells that express MARCO do not always co-express NAMPT.

###Macrophage cluster aggregation classification

At face value, it appears that `macIDR` can generate predictions on scRNAseq data, but that the predictions without an intercept make more sense as compared to predictions with an intercept. This is likely due to the difference in distribution as `macIDR` was trained on bulk transcriptomics data whose log-transformed distribution generally lies between 2 and 15. We therefore investigated whether we were capable of aggregating cells to generate a bulk distribution. We hypothesized that it would make most sense to aggregate cells that belonged to the same cluster. We will therefore redo the clustering on the macrophage subset and aggregate each cluster to form "pseudo-samples" which we will use as input for `macIDR`

```{r scrnaseq macrophage preprocessing, results = "hide", message = F}
scrasyn_mac_raw <- SubsetData(object = scrasyn_us, ident.use = 0, do.clean = T)

scrasyn_mac_raw <- NormalizeData(scrasyn_mac_raw)
scrasyn_mac_raw <- ScaleData(scrasyn_mac_raw)
scrasyn_mac_raw <- FindVariableGenes(scrasyn_mac_raw)
```

Having extracted the supposed macrophages, we will redo the clustering to find macrophage subsets.

```{r scrnaseq macrophage subclustering}
scrasyn_mac_raw <- RunPCA(object = scrasyn_mac_raw, pc.genes = scrasyn_mac_raw@var.genes, do.print = F)
scrasyn_mac_raw <- ProjectPCA(object = scrasyn_mac_raw)

PCElbowPlot(object = scrasyn_mac_raw) #9 seems like a good number based on the elbow
scrasyn_mac_raw <- FindClusters(object = scrasyn_mac_raw, reduction.type = "pca", dims.use = 1:9, resolution = 0.6, print.output = 0, save.SNN = T)
scrasyn_mac_cls <- as.factor(paste0("Mcl", as.character(scrasyn_mac_raw@ident)))
names(scrasyn_mac_cls) <- names(scrasyn_mac_raw@ident)

scrasyn_mac_raw@ident <- scrasyn_mac_cls

scrasyn_mac_raw <- RunTSNE(object = scrasyn_mac_raw, dims.use = 1:9, do.fast = T)
scrasyn_mac_raw_tsne <- TSNEPlot(object = scrasyn_mac_raw, do.return = T)

print(scrasyn_mac_raw_tsne)
```

```{r scrnaseq macrophage clusters per samples}
cluster_samples <- data.frame(cluster = scrasyn_mac_raw@ident,
                              sample = gsub("(RA[0-9])_.+", "\\1", names(scrasyn_mac_raw@ident)))
cluster_samples_table <- table(cluster_samples$cluster, cluster_samples$sample)
apply(cluster_samples_table, 2, function(macs) macs/sum(macs)*100)

round(cluster_samples_table/colSums(cluster_samples_table)*100, 2)
```

```{r scrnaseq macrophage clusters predictions}
scrasyn_mac_cl_pred <- data.frame(cluster = scrasyn_mac_raw@ident, class = scrasyn_mac_ni_preds)
(scrasyn_mac_cl_pred_prop <- table(scrasyn_mac_cl_pred$cluster, scrasyn_mac_cl_pred$class)/rowSums(table(scrasyn_mac_cl_pred$cluster, scrasyn_mac_cl_pred$class)))
```

Naturally, we are curious which genes are considered markers for each separate cluster.

```{r scrnaseq macrophage cluster genes, results = "hide", message = F}
scrasyn_mac_raw_markers <- FindAllMarkers(object = scrasyn_mac_raw, min.pct = 0.25, thresh.use = 0.25)
write.csv(scrasyn_mac_raw_markers, "mac_cluster_genes.csv")
scrasyn_mac_raw_markers %>% group_by(cluster) %>% top_n(-2, p_val)
VlnPlot(object = scrasyn_mac_raw, features.plot = c("MARCO", "CXCL9", "NAMPT"))
```

In the next chunk we aggregate according to the automatically found macrophage clusters and generate counts per million, similar to what we did previously for the bulk RNAseq. Note that we still perform the classification without intercept.

```{r scrnaseq macrophage cluster aggregation, results = "hide", message = F}
scrasyn_mac_cl_agg <- data.frame(cl0 = rowSums(scrasyn_mac_raw@raw.data[,scrasyn_mac_raw@ident == 0]),
                                 cl1 = rowSums(scrasyn_mac_raw@raw.data[,scrasyn_mac_raw@ident == 1]),
                                 cl2 = rowSums(scrasyn_mac_raw@raw.data[,scrasyn_mac_raw@ident == 2]),
                                 cl3 = rowSums(scrasyn_mac_raw@raw.data[,scrasyn_mac_raw@ident == 3]),
                                 cl4 = rowSums(scrasyn_mac_raw@raw.data[,scrasyn_mac_raw@ident == 4]),
                                 cl5 = rowSums(scrasyn_mac_raw@raw.data[,scrasyn_mac_raw@ident == 5]),
                                 cl6 = rowSums(scrasyn_mac_raw@raw.data[,scrasyn_mac_raw@ident == 6]),
                                 cl7 = rowSums(scrasyn_mac_raw@raw.data[,scrasyn_mac_raw@ident == 7]))

scrasyn_mac_cl_dglist <- DGEList(counts = scrasyn_mac_cl_agg, 
                                 samples = data.frame(c("cl0", "cl1", "cl2", "cl3", "cl4", "cl5", "cl6", "cl7")))
scrasyn_mac_cl_counts <- cpm(scrasyn_mac_cl_dglist$counts, log = T, prior.count = 1, normalized.lib.sizes = F)
rownames(scrasyn_mac_cl_counts) <- mapIds(org.Hs.eg.db,
                                          keys = rownames(scrasyn_mac_cl_counts),
                                          column = "ENTREZID",
                                          keytype = "SYMBOL",
                                          multiVals = "first")

scrasyn_mac_cl_mcObj <- macClassifier(exprs_data = scrasyn_mac_cl_counts, lor_list = stabilized_lor, intercept = T)
scrasyn_mac_cl_prop <- getProportion(scrasyn_mac_cl_mcObj)
scrasyn_mac_cl_lodds <- getLOdds(scrasyn_mac_cl_mcObj)
scrasyn_mac_cl_loddgene <- geneLOddsExtractor(scrasyn_mac_cl_mcObj, intercept = T, na.rm = F)

scrasyn_mac_cl_lodds_melt <- reshape2::melt(scrasyn_mac_cl_lodds)
colnames(scrasyn_mac_cl_lodds_melt) <- c("Mcl", "Class", "Lodds")
scrasyn_mac_cl_lodds_melt$Mcl <- paste0("M", scrasyn_mac_cl_lodds_melt$Mcl)
scrasyn_mac_cl_lodds_melt$Class <- gsub("^M([A-Za-z])", "M-\\1", scrasyn_mac_cl_lodds_melt$Class)
scrasyn_mac_cl_lodds_melt$Class <- gsub("LPSIFNg", "LPS+IFNg", scrasyn_mac_cl_lodds_melt$Class)
scrasyn_mac_cl_lodds_melt$Class <- factor(scrasyn_mac_cl_lodds_melt$Class, levels = c("M0", "M-LPSearly", "M-LPSlate", "M-LPS+IFNg", "M-IFNg", "M-IL4", "M-IL10", "M-dex"))

scrasyn_mac_cl_lodds_plotobj <- ggplot(scrasyn_mac_cl_lodds_melt, aes(x = Class, y = Lodds)) +
  geom_bar(stat = "identity") +
  facet_wrap(~Mcl, ncol = 1) +
  ylab("Log odds") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.pos = "none", 
        axis.title.x = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

print(scrasyn_mac_cl_lodds_plotobj)
apply(scrasyn_mac_cl_prop, 1, which.max)
```

As expected, we observe that classification of the pseudo-samples corresponds to the predictions made on RA SMs. We observe that most of the pseudo-samples were classified as MIL10 and that one pseudo-sample was classified as MIFNg.

#Session information

```{r session information}
sessionInfo()
```

